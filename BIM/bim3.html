<!DOCTYPE html>
<html lang="en">

<head>
 <meta charset="UTF-8">
 <title>bimModel</title>
 <script src="dat.gui.min.js"></script>
 <style>
  /* 设置 GUI 容器的样式 */
  .dg.main {
   position: absolute;
   top: 10px;
   right: 10px;
   z-index: 1;
  }

  .label {
   display: block;
   /* 确保层级足够高 */
  }

  .none {
   display: none !important;
  }


  #wind_label {
   position: absolute;
   bottom: 10px;
   left: 10px;
   background-color: rgba(83, 33, 33, 0.8);
   padding: 5px 10px;
   border-radius: 5px;
   z-index: 2;
   width: 200px;
   font-size: 10px;
   color: white;
  }

  #bridge_label {
   position: absolute;
   top: 10px;
   left: 10px;
   background-color: rgba(0, 3, 173, 0.8);
   padding: 5px 10px;
   border-radius: 5px;
   z-index: 2;
   width: 200px;
   font-size: 20px;
   color: white;

  }

  #backButton {
   position: absolute;
   bottom: 10px;
   left: 10px;
   background-color: rgba(83, 33, 33);
   padding: 5px 10px;
   border-radius: 5px;
   z-index: 2;
   font-size: 10px;
   color: white;
  }

  #viewAButton {
   position: absolute;
   bottom: 40px;
   left: 10px;
   background-color: rgba(83, 33, 33);
   padding: 5px 10px;
   border-radius: 5px;
   z-index: 2;
   font-size: 10px;
   color: white;
  }

  #viewBButton {
   position: absolute;
   bottom: 70px;
   left: 10px;
   background-color: rgba(83, 33, 33);
   padding: 5px 10px;
   border-radius: 5px;
   z-index: 2;
   font-size: 10px;
   color: white;
  }

  #viewCButton {
   position: absolute;
   bottom: 100px;
   left: 10px;
   background-color: rgba(83, 33, 33);
   padding: 5px 10px;
   border-radius: 5px;
   z-index: 2;
   font-size: 10px;
   color: white;
  }

  .fire {
   width: 30px;
   height: 30px;
  }
 </style>
</head>

<body>
 <div id="bimModel" style="width: 80vw; height: 80vh; position: absolute; top:0; left:0;">
  <div id="wind_label">10分鐘平均風速/10分鐘最大瞬間風速(KTS)<br />
   防護基準:瞬間風速達37節,不使用時應降低高度。<br />
   停橋基準:瞬間風速達48節。<br />
   綁橋基準:瞬間風速達55節。<br />
   瞬間風速達25節,暫停橋复服務。</div>
 </div>
 <div id="bimModel_bridge" style="visibility: hidden; width: 80vw; height: 80vh; position: absolute; top:0; left:0;">
  <div id="bridge_label"></div>
  <button id="backButton">返回</button> <button id="viewAButton">前</button> <button id="viewBButton">中</button> <button
   id="viewCButton">後</button>
 </div>
 <div style=" position: absolute; top:80vh; left:0;">json:<br />
  <textarea id="json" style="width:200px; height:100px"></textarea><br />
  <button id="setOverallData">bim_setOverallData</button>
  <button id="setBridgeData">bim_setBridgeData</button>
 </div>
 <div style=" position: absolute; top:80vh; left:350px;">
  event:<br />
  <textarea id="event" style="width:200px; height:100px"></textarea>
 </div>
 <script type="module">
  bim_launchView('bimModel');
  var container = document.getElementById('bimModel');
  var container_bridge = document.getElementById('bimModel_bridge');
  import * as THREE from './three.js';
  import { OrbitControls } from './OrbitControls.js';

  import { OBJLoader } from './OBJLoader.js';
  import { STLLoader } from './STLLoader.js';
  import { CSS2DRenderer, CSS2DObject } from './CSS2DRenderer.js';

  var loading = true;

  //參數區
  let planeModels = {
   selectedModel: '',
   removePlaneAction: function () {
    removePlane();
   }
  };

  let allModels = [
   null, 'A380', 'A350-900', 'A330-300', 'A321neo',
   '787-10', '777-300ER', '747-400F', '737-800'
  ];

  let bridgeAngles = {
   rotationA1: 0,
   rotationA2: 0,
   rotationA3: 0,
   rotationB1: 0,
   rotationB2: 0,
   rotationB3: 0,
   rotationC1: 0,
   rotationC2: 0,
   rotationC3: 0,
   rotationAS1: 1,
   rotationAS2: 1,
   rotationAS3: 1,
   rotationBS1: 1,
   rotationBS2: 1,
   rotationBS3: 1,
   rotationCS1: 1,
   rotationCS2: 1,
   rotationCS3: 1,
   moveBridgeAction: function () {
    moveBridge()
   },
   removeBridgeAction: function () {
    removeBridge()
   }
  };

  let camera, scene, renderer, labelRenderer, controls, raycaster, mouse, light, axesHelper;

  let camPosX, camPosY, camPosZ, camRotX, camRotY, camRotZ, controlTargetX, controlTargetY, controlTargetZ;


  let camera_bridge, scene_bridge, renderer_bridge, labelRenderer_bridge, controls_bridge, raycaster_bridge, mouse_bridge, light_bridge, axesHelper_bridge;

  //根據方向建立三個空橋陣列存放3d object
  let bridge1 = [];
  let bridge2 = [];
  let bridge3 = [];

  //空橋代碼
  let bridge_code1 = ['C18', 'C17', 'C16', 'C15', 'C14', 'C13', 'C12', 'C11'];
  let bridge_code2 = ['D18', 'D17', 'D16', 'D15', 'D14', 'D13', 'D12', 'D11'];
  let bridge_code3 = ['F1', 'F2', 'F3', 'F4', 'F5'];

  //飛機暫存
  let bridge_planeModel1 = ['', '', '', '', '', '', '', ''];
  let bridge_planeModel2 = ['', '', '', '', '', '', '', ''];
  let bridge_planeModel3 = ['', '', '', '', ''];

  let plane_currentXYA1 = [{}, {}, {}, {}, {}, {}, {}, {}];
  let plane_currentXYA2 = [{}, {}, {}, {}, {}, {}, {}, {}];
  let plane_currentXYA3 = [{}, {}, {}, {}, {}];


  let plain_info1 = [0, 0, 0, 0, 0, 0, 0, 0];
  let plain_info2 = [0, 0, 0, 0, 0, 0, 0, 0];
  let plain_info3 = [0, 0, 0, 0, 0];

  //飛機動畫
  let planeMove1 = [{}, {}, {}, {}, {}, {}, {}, {}];
  let planeMove2 = [{}, {}, {}, {}, {}, {}, {}, {}];
  let planeMove3 = [{}, {}, {}, {}, {}];

  //空橋暫存
  let bridgeAngles1 = [{}, {}, {}, {}, {}, {}, {}, {}];
  let bridgeAngles2 = [{}, {}, {}, {}, {}, {}, {}, {}];
  let bridgeAngles3 = [{}, {}, {}, {}, {}];

  //空橋動畫
  let bridgeMove1A = [{}, {}, {}, {}, {}, {}, {}, {}];
  let bridgeMove2A = [{}, {}, {}, {}, {}, {}, {}, {}];
  let bridgeMove3A = [{}, {}, {}, {}, {}];
  let bridgeMove1B = [{}, {}, {}, {}, {}, {}, {}, {}];
  let bridgeMove2B = [{}, {}, {}, {}, {}, {}, {}, {}];
  let bridgeMove3B = [{}, {}, {}, {}, {}];
  let bridgeMove1C = [{}, {}, {}, {}, {}, {}, {}, {}];
  let bridgeMove2C = [{}, {}, {}, {}, {}, {}, {}, {}];
  let bridgeMove3C = [{}, {}, {}, {}, {}];

  let planeXYA = { x: 0, y: 0, a: 0 };

  let intervalId = {};

  let enterBridgeId;

  //滑鼠事件
  let labelInfo = {
   gateClick: 'None', gateDblClick: 'None', gateMouseover: 'None',
   bridgeClick: 'None', bridgeDblClick: 'None', bridgeMouseover: 'None', modelClick: 'None'
  };

  //操控面板
  let gui = new dat.GUI();

  //camera 設定
  let C = { "position": { "x": -1.598905473937075, "y": 139.65045849972944, "z": -16.485932167992786 }, "rotation": { "_x": -1.570796326767119, "_y": 0.0000010005993815733197, "_z": 1.57076856555322, "_order": "XYZ" }, "zoom": 1, "quaternion": { "_x": -0.5000066901088709, "_y": 0.4999933097877238, "_z": 0.4999928094949773, "_w": 0.5000071904155062 }, "fov": 45, "aspect": 2.1044520547945207, "near": 0.1, "far": 5000, "target": { "x": -1.5990452080995163, "y": 3.889352887216332e-15, "z": -16.48593217187198 } };

  //空橋1
  let bridgeData1 = [{ "index": 0, "name": "sphere", "obj_type": "AL1", "position": { "x": 6.2, "y": 0.5, "z": 7.3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 1, "name": "sphere", "obj_type": "AL2", "position": { "x": 6.2, "y": 0.5, "z": 9 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 2, "name": "sphere", "obj_type": "AL3", "position": { "x": 6.2, "y": 0.5, "z": 10.2 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 3, "name": "sphere", "obj_type": "BL1", "position": { "x": 7.1, "y": 0.5, "z": 8.5 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 4, "name": "sphere", "obj_type": "BL2", "position": { "x": 7.1, "y": 0.5, "z": 10.2 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 5, "name": "sphere", "obj_type": "BL3", "position": { "x": 7.1, "y": 0.5, "z": 11.4 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 6, "name": "sphere", "obj_type": "CL1", "position": { "x": 7.1, "y": 0.5, "z": 9.7 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 7, "name": "sphere", "obj_type": "CL2", "position": { "x": 7.1, "y": 0.5, "z": 11.4 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 8, "name": "sphere", "obj_type": "CL3", "position": { "x": 7.1, "y": 0.5, "z": 12.6 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 9, "name": "cube.stl", "obj_type": "label", "position": { "x": 2, "y": 0, "z": 9 }, "scale": { "x": 0.8, "y": 0.1, "z": 0.1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#990000", "center": null }, { "index": 10, "name": "cube.stl", "obj_type": "", "position": { "x": 6, "y": 0, "z": 10 }, "scale": { "x": 0.4, "y": 0.1, "z": 0.1 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#990000", "center": null }, { "index": 11, "name": "cube.stl", "obj_type": "A1", "position": { "x": 6, "y": 0, "z": 8 }, "scale": { "x": 0.08, "y": 0.08, "z": 0.08 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": null }, { "index": 12, "name": "cube.stl", "obj_type": "B1", "position": { "x": 6.5, "y": 0, "z": 8.3 }, "scale": { "x": 0.1, "y": 0.08, "z": 0.08 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": null }, { "index": 13, "name": "cube.stl", "obj_type": "C1", "position": { "x": 6.5, "y": 0, "z": 9.5 }, "scale": { "x": 0.1, "y": 0.08, "z": 0.08 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": null }, { "index": 14, "name": "Group_29.stl", "obj_type": "A4", "position": { "x": 5.8, "y": -0.3, "z": 10.5 }, "scale": { "x": 0.3, "y": 0.3, "z": 0.6 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 6.15, "y": 0, "z": 10.57 } }, { "index": 15, "name": "Group_29.stl", "obj_type": "B4", "position": { "x": 6.7, "y": -0.3, "z": 11.6 }, "scale": { "x": 0.3, "y": 0.3, "z": 0.6 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 7, "y": 0, "z": 11.6 } }, { "index": 16, "name": "Group_29.stl", "obj_type": "C4", "position": { "x": 6.7, "y": -0.3, "z": 12.8 }, "scale": { "x": 0.3, "y": 0.3, "z": 0.6 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 7, "y": 0, "z": 12.8 } }, { "index": 17, "name": "JetwayConnector.stl", "obj_type": "A2", "position": { "x": 6.2, "y": -1, "z": 7.3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 6.25, "y": 0, "z": 7.3 } }, { "index": 18, "name": "JetwayConnector.stl", "obj_type": "B2", "position": { "x": 7.1, "y": -1, "z": 8.5 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 7.12, "y": 0, "z": 8.5 } }, { "index": 19, "name": "JetwayConnector.stl", "obj_type": "C2", "position": { "x": 7.1, "y": -1, "z": 9.7 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 7.12, "y": 0, "z": 9.77 } }, { "index": 20, "name": "CLE_JetwayGen.stl", "obj_type": "A3", "position": { "x": 6, "y": -1, "z": 7.3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 6.21, "y": 0, "z": 7.3 } }, { "index": 21, "name": "CLE_JetwayGen.stl", "obj_type": "B3", "position": { "x": 6.9, "y": -1, "z": 8.6 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 6.21, "y": 0, "z": 8.6 } }, { "index": 22, "name": "CLE_JetwayGen.stl", "obj_type": "C3", "position": { "x": 6.9, "y": -1, "z": 9.8 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 6.21, "y": 0, "z": 7.3 } }, { "index": 23, "name": "building.stl", "obj_type": "building", "position": { "x": 4, "y": -1, "z": 0.5 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#008ddb", "center": null }];

  //空橋2
  let bridgeData2 = [{ "index": 0, "name": "sphere", "obj_type": "AL1", "position": { "x": -2.3, "y": 0.5, "z": 2.7 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 1, "name": "sphere", "obj_type": "AL2", "position": { "x": -2.3, "y": 0.5, "z": 4.2 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 2, "name": "sphere", "obj_type": "AL3", "position": { "x": -2.3, "y": 0.5, "z": 5.6 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 3, "name": "sphere", "obj_type": "BL1", "position": { "x": -3.7, "y": 0.5, "z": 1.6 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 4, "name": "sphere", "obj_type": "BL2", "position": { "x": -3.7, "y": 0.5, "z": 3.3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 5, "name": "sphere", "obj_type": "BL3", "position": { "x": -3.7, "y": 0.5, "z": 4.6 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 6, "name": "sphere", "obj_type": "CL1", "position": { "x": -3.7, "y": 0.5, "z": 0.3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 7, "name": "sphere", "obj_type": "CL2", "position": { "x": -3.7, "y": 0.5, "z": 2 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 8, "name": "sphere", "obj_type": "CL3", "position": { "x": -3.7, "y": 0.5, "z": 3.3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 9, "name": "cube.stl", "obj_type": "label", "position": { "x": 1.8, "y": 0, "z": 1 }, "scale": { "x": 0.8, "y": 0.1, "z": 0.1 }, "rotation": { "_x": 0, "_y": 3.141592653589793, "_z": 0, "_order": "XYZ" }, "color": "#990000", "center": null }, { "index": 10, "name": "cube.stl", "obj_type": "", "position": { "x": -2.7, "y": 0, "z": 2 }, "scale": { "x": 0.4, "y": 0.1, "z": 0.1 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#990000", "center": null }, { "index": 11, "name": "cube.stl", "obj_type": "A1", "position": { "x": -2.65, "y": 0, "z": 2.4 }, "scale": { "x": 0.08, "y": 0.08, "z": 0.08 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": null }, { "index": 12, "name": "cube.stl", "obj_type": "B1", "position": { "x": -3.5, "y": 0, "z": 1.8 }, "scale": { "x": 0.08, "y": 0.08, "z": 0.2 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": null }, { "index": 13, "name": "cube.stl", "obj_type": "C1", "position": { "x": -3.5, "y": 0, "z": 0.5 }, "scale": { "x": 0.08, "y": 0.08, "z": 0.2 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": null }, { "index": 14, "name": "JetwayConnector.stl", "obj_type": "A2", "position": { "x": -2.4, "y": -1, "z": 2.7 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": -2.46, "y": 0, "z": 2.68 } }, { "index": 15, "name": "JetwayConnector.stl", "obj_type": "B2", "position": { "x": -3.8, "y": -1, "z": 1.6 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": -3.83, "y": 0, "z": 1.64 } }, { "index": 16, "name": "JetwayConnector.stl", "obj_type": "C2", "position": { "x": -3.8, "y": -1, "z": 0.3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": -3.83, "y": 0, "z": 0.27 } }, { "index": 17, "name": "Group_29.stl", "obj_type": "A4", "position": { "x": -2.8, "y": -0.3, "z": 5.7 }, "scale": { "x": 0.3, "y": 0.3, "z": 0.6 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": -2.36, "y": 0, "z": 5.77 } }, { "index": 18, "name": "Group_29.stl", "obj_type": "B4", "position": { "x": -4.2, "y": -0.3, "z": 4.7 }, "scale": { "x": 0.3, "y": 0.3, "z": 0.6 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": -3.77, "y": 0, "z": 4.73 } }, { "index": 19, "name": "Group_29.stl", "obj_type": "C4", "position": { "x": -4.2, "y": -0.3, "z": 3.4 }, "scale": { "x": 0.3, "y": 0.3, "z": 0.6 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": -3.77, "y": 0, "z": 3.43 } }, { "index": 20, "name": "CLE_JetwayGen.stl", "obj_type": "A3", "position": { "x": -2.6, "y": -1, "z": 2.7 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": -2.46, "y": 0, "z": 2.68 } }, { "index": 21, "name": "CLE_JetwayGen.stl", "obj_type": "B3", "position": { "x": -4, "y": -1, "z": 1.6 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": -3.83, "y": 0, "z": 1.57 } }, { "index": 22, "name": "CLE_JetwayGen.stl", "obj_type": "C3", "position": { "x": -4, "y": -1, "z": 0.3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": -3.83, "y": 0, "z": 0.27 } }, { "index": 23, "name": "building.stl", "obj_type": "building", "position": { "x": -1, "y": -1, "z": 12 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 3.141592653589793, "_z": 0, "_order": "XYZ" }, "color": "#008ddb", "center": null }];

  //空橋3
  let bridgeData3 = [{ "index": 0, "name": "sphere", "obj_type": "AL1", "position": { "x": 0.8, "y": 0.5, "z": 4.3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 1, "name": "sphere", "obj_type": "AL2", "position": { "x": 0.8, "y": 0.5, "z": 5.4 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 2, "name": "sphere", "obj_type": "AL3", "position": { "x": 0.8, "y": 0.5, "z": 6.4 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 3, "name": "cube.stl", "obj_type": "label", "position": { "x": 0.5, "y": 0, "z": 4 }, "scale": { "x": 0.8, "y": 0.1, "z": 0.1 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#990000", "center": null }, { "index": 4, "name": "cube.stl", "obj_type": "A1", "position": { "x": 0.55, "y": 0, "z": 4 }, "scale": { "x": 0.08, "y": 0.08, "z": 0.08 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": null }, { "index": 5, "name": "Group_29.stl", "obj_type": "A4", "position": { "x": 0.4, "y": -0.3, "z": 6.5 }, "scale": { "x": 0.3, "y": 0.3, "z": 0.6 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 0.8, "y": 0, "z": 6.5 } }, { "index": 6, "name": "JetwayConnector.stl", "obj_type": "A2", "position": { "x": 0.75, "y": -0.3, "z": 4.4 }, "scale": { "x": 0.5, "y": 0.5, "z": 0.5 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 0.73, "y": 0, "z": 4.4 } }, { "index": 7, "name": "CLE_JetwayGen.stl", "obj_type": "A3", "position": { "x": 0.6, "y": -1, "z": 4 }, "scale": { "x": 1, "y": 1, "z": 0.8 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": null }, { "index": 8, "name": "building.stl", "obj_type": "building", "position": { "x": 6.5, "y": -1, "z": 0.5 }, "scale": { "x": 0.45, "y": 1, "z": 0.5 }, "rotation": { "_x": 0, "_y": -1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#008ddb", "center": null }];

  //主建築
  let mainBuilding = [{ "index": 0, "name": "cube.stl", "obj_type": "", "position": { "x": -14, "y": -1, "z": -20 }, "scale": { "x": 0.2, "y": 0.5, "z": 8.1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#006600", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 1, "name": "cube.stl", "obj_type": "", "position": { "x": 13, "y": -1, "z": -20 }, "scale": { "x": 0.2, "y": 0.5, "z": 8.1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#006600", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 2, "name": "cube.stl", "obj_type": "出境1", "position": { "x": -23, "y": 0.5, "z": -1 }, "scale": { "x": 2, "y": 0.2, "z": 0.4 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#880000", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 3, "name": "cube.stl", "obj_type": "入境2", "position": { "x": 12, "y": -0.5, "z": -1 }, "scale": { "x": 2, "y": 0.2, "z": 0.4 }, "rotation": { "_x": 0, "_y": 0.4363323129985824, "_z": 0, "_order": "XYZ" }, "color": "#880000", "center": { "x": 21.7, "y": 0, "z": 0 } }, { "index": 4, "name": "cube.stl", "obj_type": "入境1", "position": { "x": -23, "y": -0.5, "z": -1 }, "scale": { "x": 2.2, "y": 0.2, "z": 0.4 }, "rotation": { "_x": 0, "_y": -0.4363323129985824, "_z": 0, "_order": "XYZ" }, "color": "#880000", "center": { "x": -22.5, "y": 0, "z": 0.1 } }, { "index": 5, "name": "cube.stl", "obj_type": "出境2", "position": { "x": 12, "y": 0.5, "z": -1 }, "scale": { "x": 2, "y": 0.2, "z": 0.4 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#880000", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 6, "name": "cube.stl", "obj_type": "ground", "position": { "x": -52, "y": -1, "z": -90 }, "scale": { "x": 20, "y": 0.01, "z": 30 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#dddddd", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 7, "name": "cube.stl", "obj_type": "", "position": { "x": -14, "y": 0.5, "z": -20 }, "scale": { "x": 5.5, "y": 0.02, "z": 8 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#dddddd", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 8, "name": "cube.stl", "obj_type": "", "position": { "x": -14, "y": 1.5, "z": -20 }, "scale": { "x": 5.5, "y": 0.1, "z": 8 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#dddddd", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 9, "name": "pillar.stl", "obj_type": "", "position": { "x": -20, "y": -1, "z": -6 }, "scale": { "x": 1, "y": 1.6, "z": 1 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#888888", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 10, "name": "pillar.stl", "obj_type": "", "position": { "x": -20, "y": -1, "z": 4 }, "scale": { "x": 1, "y": 1.6, "z": 1 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#888888", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 11, "name": "pillar.stl", "obj_type": "", "position": { "x": 20, "y": -1, "z": -6 }, "scale": { "x": 1, "y": 1.6, "z": 1 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#888888", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 12, "name": "pillar.stl", "obj_type": "", "position": { "x": 20, "y": -1, "z": 4 }, "scale": { "x": 1, "y": 1.6, "z": 1 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#888888", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 13, "name": "top3.stl", "obj_type": "", "position": { "x": 0, "y": 2, "z": 0 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#888888", "center": { "x": 0, "y": 0, "z": 0 } }];

  //飛機模型
  let planeData = [{ "index": 0, "name": "a380.stl", "obj_type": "A380" }, { "index": 1, "name": "a350-900.stl", "obj_type": "A350-900" }, { "index": 2, "name": "a330-300.stl", "obj_type": "A330-300" }, { "index": 3, "name": "a321neo.stl", "obj_type": "A321neo" }, { "index": 4, "name": "787-8.stl", "obj_type": "787-10" }, { "index": 5, "name": "777.stl", "obj_type": "777-300ER" }, { "index": 6, "name": "747-400.stl", "obj_type": "747-400F" }, { "index": 7, "name": "B737.stl", "obj_type": "737-800" }];

  let _objPlaneCollect = [, , , , , , , , , , ,];

  let gui_bridge = new dat.GUI();

  var colors_bridge = {};

  //camera 設定
  let C_bridgeC = { "position": { "x": -31.138908642283276, "y": 21.124547046100854, "z": 20.02802432713419 }, "rotation": { "_x": -0.6343495415501454, "_y": -1.1304057886682897, "_z": -0.5872580951896136, "_order": "XYZ" }, "zoom": 1, "quaternion": { "_x": -0.10482487807797901, "_y": -0.5633217718122143, "_z": -0.07233320219154937, "_w": 0.8163628079469328 }, "fov": 45, "aspect": 2.015748031496063, "near": 0.1, "far": 5000, "target": { "x": 44.496981100130974, "y": 3.4989089747618552e-15, "z": -8.681694858696433 } };

  let C_bridgeB = { "position": { "x": 22.071359802592823, "y": 24.78459126863992, "z": 41.47852024594192 }, "rotation": { "_x": -0.3937047515318204, "_y": 0.052870469233824054, "_z": 0.021948228935150135, "_order": "XYZ" }, "zoom": 1, "quaternion": { "_x": -0.19521890077614165, "_y": 0.028065674655406155, "_z": 0.005588814423002102, "_w": 0.980342115712284 }, "fov": 45, "aspect": 2.1044520547945207, "near": 0.1, "far": 5000, "target": { "x": 18.652295555277366, "y": 3.5489485507749723e-15, "z": -18.186988965429887 } };

  let C_bridgeA = { "position": { "x": 57.616532220088516, "y": 25.81896852127743, "z": -1.908670778081924 }, "rotation": { "_x": -1.5594513113168036, "_y": 0.9968965660789258, "_z": 1.557287223169511, "_order": "XYZ" }, "zoom": 1, "quaternion": { "_x": -0.20084950068515345, "_y": 0.6757069456808736, "_z": 0.19938182868205784, "_w": 0.680680900293631 }, "fov": 45, "aspect": 2.1044520547945207, "near": 0.1, "far": 5000, "target": { "x": 17.67645964620174, "y": 3.3247819950130667e-15, "z": -2.201599943268754 } };
  //空橋1
  let bridgeData = [{ "index": 0, "name": "sphere", "obj_type": "A", "position": { "x": 4, "y": 4, "z": 1.3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 1, "name": "sphere", "obj_type": "B", "position": { "x": 4.6, "y": 1, "z": 0.4 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 2, "name": "sphere", "obj_type": "C", "position": { "x": 4.9, "y": 0.3, "z": -0.5 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 3, "name": "sphere", "obj_type": "D", "position": { "x": 6, "y": 6.2, "z": -0.5 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 4, "name": "sphere", "obj_type": "E", "position": { "x": 4.8, "y": 6, "z": 0 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 5, "name": "sphere", "obj_type": "F", "position": { "x": 9, "y": 4, "z": 1.6 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 6, "name": "sphere", "obj_type": "G", "position": { "x": 19, "y": 1.5, "z": 1.7 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 7, "name": "sphere", "obj_type": "H", "position": { "x": 19, "y": 0.8, "z": 0 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 8, "name": "sphere", "obj_type": "I", "position": { "x": 13, "y": 6, "z": 0.4 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 9, "name": "sphere", "obj_type": "J", "position": { "x": 22, "y": 5, "z": 0 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 10, "name": "sphere", "obj_type": "K", "position": { "x": 23, "y": 4, "z": -1 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 11, "name": "sphere", "obj_type": "L", "position": { "x": 22, "y": 3, "z": 0.2 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ffffee", "center": null }, { "index": 12, "name": "sphere", "obj_type": "M", "position": { "x": 17, "y": 2, "z": 2 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ffffff", "center": null }, { "index": 13, "name": "sphere", "obj_type": "N", "position": { "x": 18, "y": 6, "z": 0 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ffff00", "center": null }, { "index": 14, "name": "sphere", "obj_type": "O", "position": { "x": 8, "y": 6, "z": 0 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#00ffff", "center": null }, { "index": 15, "name": "sphere", "obj_type": "P", "position": { "x": 7.2, "y": 2, "z": 1 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 16, "name": "sphere", "obj_type": "Q", "position": { "x": 10, "y": 6, "z": 1 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 17, "name": "sphere", "obj_type": "R", "position": { "x": 13, "y": 2, "z": 1.3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 18, "name": "sphere", "obj_type": "S", "position": { "x": 16, "y": 2, "z": 1.2 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 19, "name": "sphere", "obj_type": "T", "position": { "x": 18, "y": 2, "z": 1.2 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 20, "name": "sphere", "obj_type": "U", "position": { "x": 17, "y": 1.5, "z": 1.2 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 21, "name": "a380.stl", "obj_type": "a380", "position": { "x": 35, "y": -1, "z": 15 }, "scale": { "x": 5, "y": 5, "z": 5 }, "rotation": { "_x": 0, "_y": 3.141592653589793, "_z": 0, "_order": "XYZ" }, "color": "#ffffff", "center": null }, { "index": 22, "name": "Group_29.stl", "obj_type": "door", "position": { "x": 20, "y": 2, "z": 2 }, "scale": { "x": 1.5, "y": 2, "z": 1.5 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#ffffff" }];


  let _objCollect_bridge = [];

  let _collect_intervalId = {};

  let _collect_intervalId_bridge = {};

  //Method區

  function scalePoint(px, py, pz, cx, cy, cz, sx = 1, sy = 1, sz = 1) {
   // 创建点的三维向量
   let pointVector = new THREE.Vector3(px, py, pz);

   // 创建中心点的三维向量
   let centerVector = new THREE.Vector3(cx, cy, cz);

   // 计算从中心点到点的向量
   let offsetVector = new THREE.Vector3().subVectors(pointVector, centerVector);

   // 应用缩放
   offsetVector.x *= sx;
   offsetVector.y *= sy;
   offsetVector.z *= sz;

   // 计算新位置
   let newPointVector = centerVector.clone().add(offsetVector);

   // 返回新的坐标
   return newPointVector;
  }


  function rotatePoint(px, py, pz, cx, cy, cz, rx, ry, rz) {
   // 将角度从度转换为弧度
   rx = rx * Math.PI / 180;
   ry = ry * Math.PI / 180;
   rz = rz * Math.PI / 180;

   // 创建点的三维向量
   let pointVector = new THREE.Vector3(px, py, pz);

   // 创建中心点的三维向量
   let centerVector = new THREE.Vector3(cx, cy, cz);

   // 计算相对于中心点的向量
   pointVector.sub(centerVector);

   // 创建一个空的四元数用于旋转
   let quaternion = new THREE.Quaternion();

   // 绕 Y 轴旋转
   quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), ry);
   pointVector.applyQuaternion(quaternion);

   // 将旋转后的点向量加回中心点向量，恢复其世界坐标
   pointVector.add(centerVector);

   // 返回旋转后的点坐标
   return pointVector;
  }



  //重設
  function resetCameraAndControls() {
   // 设置相机的默认位置和旋转
   camera.position.set(C.position.x, C.position.y, C.position.z); // 初始位置
   camera.rotation.set(C.rotation._x, C.rotation._y, C.rotation._z); // 初始旋转

   // 设置控制器的目标点
   controls.target.set(C.target.x, C.target.y, C.target.z);

   // 更新控制器和相机
   controls.update();

   let sumX = 0, sumY = 0, sumZ = 0;
   let count = 0;

   // 计算所有对象的坐标平均值
   scene.traverse(function (object) {
    if (object.isMesh) {
     sumX += object.position.x;
     sumY += object.position.y;
     sumZ += object.position.z;
     count++;
    }
   });

   const centerX = sumX / count;
   const centerY = sumY / count;
   const centerZ = sumZ / count;

   // 设置摄像机看向新的中心点
   camera.lookAt(centerX, centerY, centerZ);
   camera.updateProjectionMatrix();

   // 同步更新 GUI 显示
   camPosX.setValue(camera.position.x);
   camPosY.setValue(camera.position.y);
   camPosZ.setValue(camera.position.z);
   camRotX.setValue(camera.rotation.x);
   camRotY.setValue(camera.rotation.y);
   camRotZ.setValue(camera.rotation.z);
   controlTargetX.setValue(controls.target.x);
   controlTargetY.setValue(controls.target.y);
   controlTargetZ.setValue(controls.target.z);
  }



  //清空空橋
  function clearAllplane() {
   bridge1.forEach(function (subArray, index) {
    bridge_planeModel1[index] = '';
    bridge1[index] = subArray.filter(function (item) {
     if (item.obj_type == 'plane') scene.remove(item);
     return item.obj_name !== 'a380.stl';  // 只保留 object_name 不等于 'xxx' 的对象
    });
    setPlaneData(bridge_code1[index], '');
    setWindData(bridge_code1[index], '');
   });
   bridge2.forEach(function (subArray, index) {
    bridge_planeModel2[index] = '';
    bridge2[index] = subArray.filter(function (item) {
     if (item.obj_type == 'plane') scene.remove(item);
     return item.obj_name !== 'a380.stl';  // 只保留 object_name 不等于 'xxx' 的对象
    });
    setPlaneData(bridge_code2[index], '');
    setWindData(bridge_code2[index], '');
   });
   bridge3.forEach(function (subArray, index) {
    bridge_planeModel3[index] = '';
    bridge3[index] = subArray.filter(function (item) {
     if (item.obj_type == 'plane') scene.remove(item);
     return item.obj_name !== 'a380.stl';  // 只保留 object_name 不等于 'xxx' 的对象
    });
    setPlaneData(bridge_code3[index], '');
    setWindData(bridge_code3[index], '');
   });


   //重設空橋
   for (var c = 0; c < 8; c++) {

    bridgeAngles1[c] = {
     'A2': 90, 'A3': 0,
     'B2': 90, 'B3': 0,
     'C2': 90, 'C3': 0,
     'AS2': 0.2, 'AS3': 0.6,
     'BS2': 0.2, 'BS3': 0.6,
     'CS2': 0.2, 'CS3': 0.6
    };

    rotateBridge(bridgeData1, bridge1[c], c, 'A', 90, 0, 0.2, 0.6, 20, 0, -20, 10);
    rotateBridge(bridgeData1, bridge1[c], c, 'B', 90, 0, 0.2, 0.6, 20, 0, -20, 10);
    rotateBridge(bridgeData1, bridge1[c], c, 'C', 90, 0, 0.2, 0.6, 20, 0, -20, 10);
   }
   for (var c = 0; c < 8; c++) {
    bridgeAngles2[c] = {
     'A2': -90, 'A3': 0,
     'B2': -90, 'B3': 0,
     'C2': -90, 'C3': 0,
     'AS2': 0.2, 'AS3': 0.6,
     'BS2': 0.2, 'BS3': 0.6,
     'CS2': 0.2, 'CS3': 0.6
    };

    rotateBridge(bridgeData2, bridge2[c], c, 'A', -90, 0, 0.2, 0.6, -25, 0, -20, 10);
    rotateBridge(bridgeData2, bridge2[c], c, 'B', -90, 0, 0.2, 0.6, -25, 0, -20, 10);
    rotateBridge(bridgeData2, bridge2[c], c, 'C', -90, 0, 0.2, 0.6, -25, 0, -20, 10);
   }
   for (var c = 0; c < 5; c++) {
    bridgeAngles2[c] = {
     'A2': 160, 'A3': -70,
     'AS2': 0.2, 'AS3': 0.6,
    };
    rotateBridge(bridgeData3, bridge3[c], c, 'A', 160, -70, 0.2, 0.6, -15, 6, -23, 0);
   }

  }

  function setBridgeAngle(ABC) {
   var no = labelInfo.gateClick;

   var i1 = bridge_code1.findIndex(x => x == no);
   var i2 = bridge_code2.findIndex(x => x == no);
   var i3 = bridge_code3.findIndex(x => x == no);

   if (i1 > -1) {
    bridgeAngles1[i1] = {
     'A2': bridgeAngles.rotationA2, 'A3': bridgeAngles.rotationA3,
     'B2': bridgeAngles.rotationB2, 'B3': bridgeAngles.rotationB3,
     'C2': bridgeAngles.rotationC2, 'C3': bridgeAngles.rotationC3,
     'AS2': bridgeAngles.rotationAS2, 'AS3': bridgeAngles.rotationAS3,
     'BS2': bridgeAngles.rotationBS2, 'BS3': bridgeAngles.rotationBS3,
     'CS2': bridgeAngles.rotationCS2, 'CS3': bridgeAngles.rotationCS3
    };
    if (ABC == 'A')
     rotateBridge(bridgeData1, bridge1[i1], i1, ABC,
      bridgeAngles.rotationA2, bridgeAngles.rotationA3,
      bridgeAngles.rotationAS2, bridgeAngles.rotationAS3,
      20, 0, -20, 10);
    if (ABC == 'B')
     rotateBridge(bridgeData1, bridge1[i1], i1, ABC,
      bridgeAngles.rotationB2, bridgeAngles.rotationB3,
      bridgeAngles.rotationBS2, bridgeAngles.rotationBS3,
      20, 0, -20, 10);
    if (ABC == 'C')
     rotateBridge(bridgeData1, bridge1[i1], i1, ABC,
      bridgeAngles.rotationC2, bridgeAngles.rotationC3,
      bridgeAngles.rotationCS2, bridgeAngles.rotationCS3,
      20, 0, -20, 10);
   }
   if (i2 > -1) {
    bridgeAngles2[i2] = {
     'A2': bridgeAngles.rotationA2, 'A3': bridgeAngles.rotationA3,
     'B2': bridgeAngles.rotationB2, 'B3': bridgeAngles.rotationB3,
     'C2': bridgeAngles.rotationC2, 'C3': bridgeAngles.rotationC3,
     'AS2': bridgeAngles.rotationAS2, 'AS3': bridgeAngles.rotationAS3,
     'BS2': bridgeAngles.rotationBS2, 'BS3': bridgeAngles.rotationBS3,
     'CS2': bridgeAngles.rotationCS2, 'CS3': bridgeAngles.rotationCS3
    };
    if (ABC == 'A')
     rotateBridge(bridgeData2, bridge2[i2], i2, ABC,
      bridgeAngles.rotationA2, bridgeAngles.rotationA3,
      bridgeAngles.rotationAS2, bridgeAngles.rotationAS3,
      -25, 0, -20, 10);
    if (ABC == 'B')
     rotateBridge(bridgeData2, bridge2[i2], i2, ABC,
      bridgeAngles.rotationB2, bridgeAngles.rotationB3,
      bridgeAngles.rotationBS2, bridgeAngles.rotationBS3,
      -25, 0, -20, 10);
    if (ABC == 'C')
     rotateBridge(bridgeData2, bridge2[i2], i2, ABC,
      bridgeAngles.rotationC2, bridgeAngles.rotationC3,
      bridgeAngles.rotationCS2, bridgeAngles.rotationCS3,
      -25, 0, -20, 10);
   }

   if (i3 > -1) {
    bridgeAngles3[i3] = {
     'A2': bridgeAngles.rotationA2, 'A3': bridgeAngles.rotationA3,
     'AS2': bridgeAngles.rotationAS2, 'AS3': bridgeAngles.rotationAS3,
    };
    rotateBridge(bridgeData3, bridge3[i3], i3, ABC,
     bridgeAngles.rotationA2, bridgeAngles.rotationA3,
     bridgeAngles.rotationAS2, bridgeAngles.rotationAS3,
     -15, 6, -23, 0);
   }
  }



  function runBridgeA(no, obj, i1, i2, i3) {
   runBridge(no, obj.A2, obj.A3,
    null, null,
    null, null,
    obj.AS2, obj.AS3,
    null, null,
    null, null);
  }
  function runBridgeB(no, obj, i1, i2, i3) {
   runBridge(no, null, null,
    obj.B2, obj.B3,
    null, null,
    null, null,
    obj.BS2, obj.BS3,
    null, null);
  }
  function runBridgeC(no, obj, i1, i2, i3) {
   runBridge(no, null, null,
    null, null,
    obj.C2, obj.C3,
    null, null,
    null, null,
    obj.CS2, obj.CS3);
  }
  function runBridge(no, A2, A3, B2, B3, C2, C3, AS2, AS3, BS2, BS3, CS2, CS3) {

   var i1 = bridge_code1.findIndex(x => x == no);
   var i2 = bridge_code2.findIndex(x => x == no);
   var i3 = bridge_code3.findIndex(x => x == no);

   if (i1 > -1) {
    if (A2 == null) A2 = bridgeAngles1[i1].A2;
    if (A3 == null) A3 = bridgeAngles1[i1].A3;
    if (B2 == null) B2 = bridgeAngles1[i1].B2;
    if (B3 == null) B3 = bridgeAngles1[i1].B3;
    if (C2 == null) C2 = bridgeAngles1[i1].C2;
    if (C3 == null) C3 = bridgeAngles1[i1].C3;
    if (AS2 == null) AS2 = bridgeAngles1[i1].AS2;
    if (AS3 == null) AS3 = bridgeAngles1[i1].AS3;
    if (BS2 == null) BS2 = bridgeAngles1[i1].BS2;
    if (BS3 == null) BS3 = bridgeAngles1[i1].BS3;
    if (CS2 == null) CS2 = bridgeAngles1[i1].CS2;
    if (CS3 == null) CS3 = bridgeAngles1[i1].CS3;
    bridgeAngles1[i1] = {
     'A2': A2, 'A3': A3,
     'B2': B2, 'B3': B3,
     'C2': C2, 'C3': C3,
     'AS2': AS2, 'AS3': AS3,
     'BS2': BS2, 'BS3': BS3,
     'CS2': CS2, 'CS3': CS3
    };
    rotateBridge(bridgeData1, bridge1[i1], i1, 'A',
     A2, A3,
     AS2, AS3,
     20, 0, -20, 10);
    rotateBridge(bridgeData1, bridge1[i1], i1, 'B',
     B2, B3,
     BS2, BS3,
     20, 0, -20, 10);
    rotateBridge(bridgeData1, bridge1[i1], i1, 'C',
     C2, C3,
     CS2, CS3,
     20, 0, -20, 10);
   }
   if (i2 > -1) {
    if (A2 == null) A2 = bridgeAngles2[i2].A2;
    if (A3 == null) A3 = bridgeAngles2[i2].A3;
    if (B2 == null) B2 = bridgeAngles2[i2].B2;
    if (B3 == null) B3 = bridgeAngles2[i2].B3;
    if (C2 == null) C2 = bridgeAngles2[i2].C2;
    if (C3 == null) C3 = bridgeAngles2[i2].C3;
    if (AS2 == null) AS2 = bridgeAngles2[i2].AS2;
    if (AS3 == null) AS3 = bridgeAngles2[i2].AS3;
    if (BS2 == null) BS2 = bridgeAngles2[i2].BS2;
    if (BS3 == null) BS3 = bridgeAngles2[i2].BS3;
    if (CS2 == null) CS2 = bridgeAngles2[i2].CS2;
    if (CS3 == null) CS3 = bridgeAngles2[i2].CS3;
    bridgeAngles2[i2] = {
     'A2': A2, 'A3': A3,
     'B2': B2, 'B3': B3,
     'C2': C2, 'C3': C3,
     'AS2': AS2, 'AS3': AS3,
     'BS2': BS2, 'BS3': BS3,
     'CS2': CS2, 'CS3': CS3
    };
    rotateBridge(bridgeData2, bridge2[i2], i2, 'A',
     A2 - 180, A3,
     AS2, AS3,
     -25, 0, -20, 10);
    rotateBridge(bridgeData2, bridge2[i2], i2, 'B',
     B2 - 180, B3,
     BS2, BS3,
     -25, 0, -20, 10);
    rotateBridge(bridgeData2, bridge2[i2], i2, 'C',
     C2 - 180, C3,
     CS2, CS3,
     -25, 0, -20, 10);
   }

   if (i3 > -1) {
    if (A2 == null) A2 = bridgeAngles3[i3].A2;
    if (A3 == null) A3 = bridgeAngles3[i3].A3;
    if (AS2 == null) AS2 = bridgeAngles3[i3].AS2;
    if (AS3 == null) AS3 = bridgeAngles3[i3].AS3;
    bridgeAngles3[i3] = {
     'A2': A2, 'A3': A3,
     'AS2': AS2, 'AS3': AS3,
    };
    rotateBridge(bridgeData3, bridge3[i3], i3, 'A',
     A2, A3,
     AS2, AS3,
     -15, 6, -23, 0);
   }
  }

  function setPlaneXYA(no, xya) {
   if (!no) no = labelInfo.gateClick;
   if (!xya) xya = planeXYA;
   var i1 = bridge_code1.findIndex(x => x == no);
   var i2 = bridge_code2.findIndex(x => x == no);
   var i3 = bridge_code3.findIndex(x => x == no);

   if (i1 > -1) {
    var i = bridge1[i1].findIndex(x => x.obj_type == 'plane');
    if (i == -1) return;
    if (xya.a != -100000) bridge1[i1][i].rotation.set(bridge1[i1][i].rotation._x, xya.a / 180 * Math.PI, bridge1[i1][i].rotation._z);
    bridge1[i1][i].position.set(xya.x, -1, xya.y);
    if (bridge1[i1][i].transparent) {
     bridge1[i1][i].transparent = false;
     bridge1[i1][i].opacity = 1;
    }
    plane_currentXYA1[i1] = xya;
   }
   if (i2 > -1) {
    var i = bridge2[i2].findIndex(x => x.obj_type == 'plane');
    if (i == -1) return;
    if (xya.a != -100000) bridge2[i2][i].rotation.set(bridge2[i2][i].rotation._x, xya.a / 180 * Math.PI, bridge2[i2][i].rotation._z);
    bridge2[i2][i].position.set(xya.x, -1, xya.y);
    if (bridge2[i2][i].transparent) {
     bridge2[i2][i].transparent = false;
     bridge2[i2][i].opacity = 1;
    }
    plane_currentXYA2[i2] = xya;
   }
   if (i3 > -1) {
    var i = bridge3[i3].findIndex(x => x.obj_type == 'plane');
    if (i == -1) return;
    if (xya.a != -100000) bridge3[i3][i].rotation.set(bridge3[i3][i].rotation._x, xya.a / 180 * Math.PI, bridge3[i3][i].rotation._z);
    bridge3[i3][i].position.set(xya.x, -1, xya.y);
    if (bridge3[i3][i].transparent) {
     bridge3[i3][i].transparent = false;
     bridge3[i3][i].opacity = 1;
    }
    plane_currentXYA3[i3] = xya;
   }
   if (no == labelInfo.gateClick) {
    planeXYA.x = xya.x;
    planeXYA.y = xya.y;
    planeXYA.a = xya.a;
    gui.updateDisplay(); // 更新 GUI 显示
   }
  }

  function setPlaneInfoTimeout(no) {
   var i1 = bridge_code1.findIndex(x => x == no);
   var i2 = bridge_code2.findIndex(x => x == no);
   var i3 = bridge_code3.findIndex(x => x == no);

   if (i1 > -1) {
    plain_info1[i1] = 5;
   }
   if (i2 > -1) {
    plain_info2[i2] = 5;
   }
   if (i3 > -1) {
    plain_info3[i3] = 5;
   }
  }
  //設定飛機
  function setPlane(no, m) {
   if (!no) no = labelInfo.modelClick;
   if (!m) m = planeModels.selectedModel;
   var i1 = bridge_code1.findIndex(x => x == no);
   var i2 = bridge_code2.findIndex(x => x == no);
   var i3 = bridge_code3.findIndex(x => x == no);

   var setPlane_i = planeData.findIndex(x => x.obj_type == m);
   if (setPlane_i == -1) setPlane_i = 0;
   /*
 function addModel(_objCollect, labelData, name, c, 
 position, rotation, center, scale, color, 
 xOffset = 0, xIncrement = 0, zOffset = 0, zIncrement = 0)*/
   if (i1 > -1) {
    if (bridge_planeModel1[i1] == m) return;
    clearPlane(no);
    addModel(bridge1, bridge_code1, _objPlaneCollect[setPlane_i], i1, '#ffffff', m);
    bridge_planeModel1[i1] = m;
    setPlaneMove(planeMove1, 1, i1, m);
    runBridge(no, bridge_move[m].from.A2, bridge_move[m].from.A3,
     bridge_move[m].from.B2, bridge_move[m].from.B3,
     bridge_move[m].from.C2, bridge_move[m].from.C3,
     bridge_move[m].from.AS2, bridge_move[m].from.AS3,
     bridge_move[m].from.BS2, bridge_move[m].from.BS3,
     bridge_move[m].from.CS2, bridge_move[m].from.CS3);

   }
   if (i2 > -1) {
    if (bridge_planeModel2[i2] == m) return;
    clearPlane(no);
    addModel(bridge2, bridge_code2, _objPlaneCollect[setPlane_i], i2, '#ffffff', m);
    bridge_planeModel2[i2] = m;
    setPlaneMove(planeMove2, 2, i2, m);
    runBridge(no, bridge_move[m].from.A2, bridge_move[m].from.A3,
     bridge_move[m].from.B2, bridge_move[m].from.B3,
     bridge_move[m].from.C2, bridge_move[m].from.C3,
     bridge_move[m].from.AS2, bridge_move[m].from.AS3,
     bridge_move[m].from.BS2, bridge_move[m].from.BS3,
     bridge_move[m].from.CS2, bridge_move[m].from.CS3);

   }
   if (i3 > -1) {
    if (bridge_planeModel3[i3] == m) return;
    clearPlane(no);
    addModel(bridge3, bridge_code3, _objPlaneCollect[setPlane_i], i3, '#ffffff', m);
    bridge_planeModel3[i3] = m;
    setPlaneMove(planeMove3, 3, i3, m);
    runBridge(no, bridge_move3[m].from.A2, bridge_move3[m].from.A3,
     null, null,
     null, null,
     bridge_move3[m].from.AS2, bridge_move3[m].from.AS3,
     null, null,
     null, null);

   }
  }

  function removePlane(no) {
   if (!no) no = labelInfo.gateClick;
   var i1 = bridge_code1.findIndex(x => x == no);
   var i2 = bridge_code2.findIndex(x => x == no);
   var i3 = bridge_code3.findIndex(x => x == no);

   if (i1 > -1) {
    setPlaneMoveout(planeMove1, 1, i1);
   }
   if (i2 > -1) {
    setPlaneMoveout(planeMove2, 2, i2);
   }
   if (i3 > -1) {
    setPlaneMoveout(planeMove3, 3, i3);
   }
  }

  function calcAngle(x1, z1, x2, z2) {
   const point1 = new THREE.Vector3(x1, 1, z1);
   const point2 = new THREE.Vector3(x2, 1, z2);

   // 計算 point1 到 point2 的向量
   const directionVector = new THREE.Vector3().subVectors(point2, point1);

   // 獲得方向向量在 x-z 平面上的角度
   const angle = Math.atan2(directionVector.x, directionVector.z);

   // 將角度從弧度轉換為度
   const angleDegrees = angle * (180 / Math.PI);

   // 獲得方向向量在 x-z 平面上的角度
   return angleDegrees;
  }

  function setPlaneMove(moveArray, d, c, m) {

   if (d == 1) {
    var xOffset = 20, xIncrement = 0, zOffset = -25, zIncrement = 10;
    var cX = 22.5 + xOffset + c * xIncrement; // 設置中心點X坐標（正方形的中心點）
    var cY = 1;                               // 半圓弧在Y軸上的高度，與正方形相同
    var cZ = 27.5 - c * zIncrement;             // 設置中心點Z坐標（正方形底邊的中點）
    var radius = 2.5;                              // 半圓弧的半徑
    var startAngle = 0;                  // 起始角度，Math.PI/2 代表90度
    var endAngle = -Math.PI / 2;                   // 終止角度，-Math.PI/2 代表-90度
    var segments = 32;                             // 半圓弧的分段數，增加此數值可使弧更平滑

    var pointsA = [];

    for (var i = 60; i > 27.5 - c * zIncrement; i--) {
     pointsA.push({ x: 45, y: i, a: pointsA.length == 0 ? -100000 : calcAngle(pointsA[pointsA.length - 1].x, pointsA[pointsA.length - 1].y, 45, i) });
    }

    for (var i = 0; i <= segments; i++) {
     var theta = startAngle + (endAngle - startAngle) * (i / segments);
     var x = cX + radius * Math.cos(theta);
     var z = cZ + radius * Math.sin(theta); x
     pointsA.push({ x: x, y: z, a: calcAngle(pointsA[pointsA.length - 1].x, pointsA[pointsA.length - 1].y, x, z) });
    }

    for (var i = 22; i > 13; i -= 0.5) {
     pointsA.push({
      x: i + xOffset + c * xIncrement, y: - zOffset - c * zIncrement, a: calcAngle(pointsA[pointsA.length - 1].x, pointsA[pointsA.length - 1].y, i + xOffset + c * xIncrement, - zOffset - c * zIncrement)
     });
    }
    moveArray[c] = { points: pointsA, current: 0, type: 'enter' };
   }



   if (d == 2) {
    var xOffset = -25, xIncrement = 0, zOffset = -25, zIncrement = 10;
    var cX = -42.5 - c * xIncrement; // 設置中心點X坐標（正方形的中心點）
    var cY = 1;                               // 半圓弧在Y軸上的高度，與正方形相同
    var cZ = 22.5 - c * zIncrement;             // 設置中心點Z坐標（正方形底邊的中點）
    var radius = 2.5;                              // 半圓弧的半徑
    var startAngle = Math.PI;                  // 起始角度，Math.PI/2 代表90度
    var endAngle = Math.PI / 2;                   // 終止角度，-Math.PI/2 代表-90度
    var segments = 32;                             // 半圓弧的分段數，增加此數值可使弧更平滑
    var pointsA = [];

    for (var i = -90; i < 22.5 - c * zIncrement; i++) {
     pointsA.push({ x: -45, y: i, a: pointsA.length == 0 ? -100000 : calcAngle(pointsA[pointsA.length - 1].x, pointsA[pointsA.length - 1].y, -45, i) });
    }
    for (var i = 0; i <= segments; i++) {
     var theta = startAngle + (endAngle - startAngle) * (i / segments);
     var x = cX + radius * Math.cos(theta);
     var z = cZ + radius * Math.sin(theta);
     pointsA.push({ x: x, y: z, a: calcAngle(pointsA[pointsA.length - 1].x, pointsA[pointsA.length - 1].y, x, z) });
    }

    // -45  -35
    for (var i = -42; i < -34; i += 0.5) {
     pointsA.push({
      x: i + c * xIncrement, y: - zOffset - c * zIncrement, a: calcAngle(pointsA[pointsA.length - 1].x, pointsA[pointsA.length - 1].y, i + c * xIncrement, - zOffset - c * zIncrement)
     });
    }

    moveArray[c] = { points: pointsA, current: 0, type: 'enter' };
   }




   if (d == 3) {
    // -12, 5, -23, 0  -15, 6
    var xOffset = -15, xIncrement = 6, zOffset = -23, zIncrement = 0;
    var cX = -14 + c * xIncrement; // 設置中心點X坐標（正方形的中心點）
    var cY = 1;                               // 半圓弧在Y軸上的高度，與正方形相同
    var cZ = 37.5 - c * zIncrement;             // 設置中心點Z坐標（正方形底邊的中點）
    var radius = 2.5;                              // 半圓弧的半徑
    var startAngle = Math.PI / 2;                  // 起始角度，Math.PI/2 代表90度
    var endAngle = 0;                   // 終止角度，-Math.PI/2 代表-90度
    var segments = 32;                             // 半圓弧的分段數，增加此數值可使弧更平滑


    var pointsA = [];
    for (var i = -55; i < -14 + c * xIncrement; i++) {
     pointsA.push({ x: i, y: 40, a: pointsA.length == 0 ? -100000 : calcAngle(pointsA[pointsA.length - 1].x, pointsA[pointsA.length - 1].y, i, 40) });
    }
    for (var i = 0; i <= segments; i++) {
     var theta = startAngle + (endAngle - startAngle) * (i / segments);
     var x = cX + radius * Math.cos(theta);
     var z = cZ + radius * Math.sin(theta);
     pointsA.push({ x: x, y: z, a: calcAngle(pointsA[pointsA.length - 1].x, pointsA[pointsA.length - 1].y, x, z) });
    }

    for (var i = 37; i > 29; i -= 0.5) {
     pointsA.push({ x: -11.5 + c * xIncrement, y: i, a: calcAngle(pointsA[pointsA.length - 1].x, pointsA[pointsA.length - 1].y, -11.5 + c * xIncrement, i) });
    }

    moveArray[c] = { points: pointsA, current: 0, type: 'enter' };
   }

  }


  function setPlaneMoveout(moveArray, d, c) {
   if (d == 1) {
    var xOffset = 20, xIncrement = 0, zOffset = -25, zIncrement = 10;
    var cX = 22.5 + xOffset + c * xIncrement; // 設置中心點X坐標（正方形的中心點）
    var cY = 1;                               // 半圓弧在Y軸上的高度，與正方形相同
    var cZ = 27.5 - c * zIncrement;             // 設置中心點Z坐標（正方形底邊的中點）
    var radius = 2.5;                              // 半圓弧的半徑
    var startAngle = 0;                  // 起始角度，Math.PI/2 代表90度
    var endAngle = -Math.PI / 2;                   // 終止角度，-Math.PI/2 代表-90度
    var segments = 32;                             // 半圓弧的分段數，增加此數值可使弧更平滑

    var pointsA = [];

    for (var i = 13.5; i < 22; i += 0.5) {
     pointsA.push({
      x: i + xOffset + c * xIncrement, y: - zOffset - c * zIncrement,
      a: pointsA.length == 0 ? -100000 : calcAngle(i + xOffset + c * xIncrement, - zOffset - c * zIncrement, pointsA[pointsA.length - 1].x, pointsA[pointsA.length - 1].y)
     });
    }
    for (var i = segments; i >= 0; i--) {
     var theta = startAngle + (endAngle - startAngle) * (i / segments);
     var x = cX + radius * Math.cos(theta);
     var z = cZ + radius * Math.sin(theta); x
     pointsA.push({ x: x, y: z, a: calcAngle(x, z, pointsA[pointsA.length - 1].x, pointsA[pointsA.length - 1].y) });
    }

    for (var i = 27 - c * zIncrement; i > -100; i--) {
     pointsA.push({ x: 45, y: i, a: calcAngle(pointsA[pointsA.length - 1].x, pointsA[pointsA.length - 1].y, 45, i) });
    }

    moveArray[c] = { points: pointsA, current: 0, type: 'leave' };
   }



   if (d == 2) {
    var xOffset = -25, xIncrement = 0, zOffset = -25, zIncrement = 10;
    var cX = -42.5 - c * xIncrement; // 設置中心點X坐標（正方形的中心點）
    var cY = 1;                               // 半圓弧在Y軸上的高度，與正方形相同
    var cZ = 22.5 - c * zIncrement;             // 設置中心點Z坐標（正方形底邊的中點）
    var radius = 2.5;                              // 半圓弧的半徑
    var startAngle = Math.PI;                  // 起始角度，Math.PI/2 代表90度
    var endAngle = Math.PI / 2;                   // 終止角度，-Math.PI/2 代表-90度
    var segments = 32;                             // 半圓弧的分段數，增加此數值可使弧更平滑
    var pointsA = [];

    for (var i = -34.5; i > -41.5; i -= 0.5) {
     pointsA.push({
      x: i + c * xIncrement, y: - zOffset - c * zIncrement,
      a: pointsA.length == 0 ? -100000 : calcAngle(i + c * xIncrement, - zOffset - c * zIncrement, pointsA[pointsA.length - 1].x, pointsA[pointsA.length - 1].y)
     });
    }
    for (var i = segments; i >= 0; i--) {
     var theta = startAngle + (endAngle - startAngle) * (i / segments);
     var x = cX + radius * Math.cos(theta);
     var z = cZ + radius * Math.sin(theta);
     pointsA.push({ x: x, y: z, a: calcAngle(x, z, pointsA[pointsA.length - 1].x, pointsA[pointsA.length - 1].y) });
    }

    for (var i = 22.5 - c * zIncrement; i < 90; i++) {
     pointsA.push({ x: -45, y: i, a: calcAngle(pointsA[pointsA.length - 1].x, pointsA[pointsA.length - 1].y, -45, i) });
    }

    moveArray[c] = { points: pointsA, current: 0, type: 'leave' };
   }




   if (d == 3) {
    // -12, 5, -23, 0
    var xOffset = -15, xIncrement = 6, zOffset = -23, zIncrement = 0;
    var cX = -14 + c * xIncrement; // 設置中心點X坐標（正方形的中心點）
    var cY = 1;                               // 半圓弧在Y軸上的高度，與正方形相同
    var cZ = 37.5 - c * zIncrement;             // 設置中心點Z坐標（正方形底邊的中點）
    var radius = 2.5;                              // 半圓弧的半徑
    var startAngle = Math.PI / 2;                  // 起始角度，Math.PI/2 代表90度
    var endAngle = 0;                   // 終止角度，-Math.PI/2 代表-90度
    var segments = 32;                             // 半圓弧的分段數，增加此數值可使弧更平滑


    var pointsA = [];

    for (var i = 29.5; i < 37; i += 0.5) {
     pointsA.push({ x: -11.5 + c * xIncrement, y: i, a: pointsA.length == 0 ? -100000 : calcAngle(-11.5 + c * xIncrement, i, pointsA[pointsA.length - 1].x, pointsA[pointsA.length - 1].y) });
    }

    for (var i = segments; i >= 0; i--) {
     var theta = startAngle + (endAngle - startAngle) * (i / segments);
     var x = cX + radius * Math.cos(theta);
     var z = cZ + radius * Math.sin(theta);
     pointsA.push({ x: x, y: z, a: calcAngle(x, z, pointsA[pointsA.length - 1].x, pointsA[pointsA.length - 1].y) });
    }
    for (var i = -11 + c * xIncrement; i < 55; i++) {
     pointsA.push({ x: i, y: 40, a: calcAngle(pointsA[pointsA.length - 1].x, pointsA[pointsA.length - 1].y, i, 40) });
    }
    moveArray[c] = { points: pointsA, current: 0, type: 'leave' };
   }

  }

  let bridge_move = { 'A380': { from: { A2: 90, A3: 0, AS2: 0, AS3: 0.3, B2: 90, B3: 0, BS2: 0, BS3: 0.3, C2: 90, C3: 0, CS2: 0, CS3: 0.3 }, to: { A2: 111, A3: 62, AS2: 1.2, AS3: 0.3, B2: 120, B3: 62, BS2: 2.3, BS3: 0.3, C2: 120, C3: 46, CS2: 2.3, CS3: 1 } }, 'A350-900': { from: { A2: 90, A3: 0, AS2: 0, AS3: 0.3, B2: 90, B3: 0, BS2: 0, BS3: 0.3, C2: 90, C3: 0, CS2: 0, CS3: 0.3 }, to: { A2: 111, A3: 62, AS2: 1.2, AS3: 0.3, B2: 120, B3: 62, BS2: 2.3, BS3: 0.3, C2: 120, C3: 46, CS2: 2.3, CS3: 1 } }, 'A330-300': { from: { A2: 90, A3: 0, AS2: 0, AS3: 0.3, B2: 90, B3: 0, BS2: 0, BS3: 0.3, C2: 90, C3: 0, CS2: 0, CS3: 0.3 }, to: { A2: 111, A3: 62, AS2: 1.2, AS3: 0.3, B2: 120, B3: 62, BS2: 2.3, BS3: 0.3, C2: 120, C3: 46, CS2: 2.3, CS3: 1 } }, 'A321neo': { from: { A2: 90, A3: 0, AS2: 0, AS3: 0.3, B2: 90, B3: 0, BS2: 0, BS3: 0.3, C2: 90, C3: 0, CS2: 0, CS3: 0.3 }, to: { A2: 107, A3: 72, AS2: 2.3, AS3: 0.3, B2: 120, B3: 62, BS2: 2.3, BS3: 0.3, C2: 120, C3: 46, CS2: 2.3, CS3: 1 } }, '787-10': { from: { A2: 90, A3: 0, AS2: 0, AS3: 0.3, B2: 90, B3: 0, BS2: 0, BS3: 0.3, C2: 90, C3: 0, CS2: 0, CS3: 0.3 }, to: { A2: 111, A3: 62, AS2: 1.2, AS3: 0.3, B2: 120, B3: 62, BS2: 2.3, BS3: 0.3, C2: 120, C3: 46, CS2: 2.3, CS3: 1 } }, '777-300ER': { from: { A2: 90, A3: 0, AS2: 0, AS3: 0.3, B2: 90, B3: 0, BS2: 0, BS3: 0.3, C2: 90, C3: 0, CS2: 0, CS3: 0.3 }, to: { A2: 111, A3: 62, AS2: 1.2, AS3: 0.3, B2: 120, B3: 62, BS2: 2.3, BS3: 0.3, C2: 120, C3: 46, CS2: 2.3, CS3: 1 } }, '747-400F': { from: { A2: 90, A3: 0, AS2: 0, AS3: 0.3, B2: 90, B3: 0, BS2: 0, BS3: 0.3, C2: 90, C3: 0, CS2: 0, CS3: 0.3 }, to: { A2: 111, A3: 62, AS2: 1.2, AS3: 0.3, B2: 120, B3: 62, BS2: 2.3, BS3: 0.3, C2: 120, C3: 46, CS2: 2.3, CS3: 1 } }, '737-800': { from: { A2: 90, A3: 0, AS2: 0, AS3: 0.3, B2: 90, B3: 0, BS2: 0, BS3: 0.3, C2: 90, C3: 0, CS2: 0, CS3: 0.3 }, to: { A2: 111, A3: 62, AS2: 1.2, AS3: 0.3, B2: 120, B3: 62, BS2: 2.3, BS3: 0.3, C2: 120, C3: 46, CS2: 2.3, CS3: 1 } } }

  let bridge_move3 = { 'A380': { from: { A2: 170, A3: 4, AS2: 0, AS2: 0, }, to: { A2: 137, A3: -49, AS2: 0, AS2: 0.6 } }, 'A350-900': { from: { A2: 170, A3: 4, AS2: 0, AS2: 0, }, to: { A2: 137, A3: -49, AS2: 0, AS2: 0.6 } }, 'A330-300': { from: { A2: 170, A3: 4, AS2: 0, AS2: 0, }, to: { A2: 137, A3: -49, AS2: 0, AS2: 0.6 } }, 'A321neo': { from: { A2: 170, A3: 4, AS2: 0, AS2: 0, }, to: { A2: 137, A3: -49, AS2: 0, AS2: 0.6 } }, '787-10': { from: { A2: 170, A3: 4, AS2: 0, AS2: 0, }, to: { A2: 137, A3: -49, AS2: 0, AS2: 0.6 } }, '777-300ER': { from: { A2: 170, A3: 4, AS2: 0, AS2: 0, }, to: { A2: 137, A3: -49, AS2: 0, AS2: 0.6 } }, '747-400F': { from: { A2: 170, A3: 4, AS2: 0, AS2: 0, }, to: { A2: 137, A3: -49, AS2: 0, AS2: 0.6 } }, '737-800': { from: { A2: 170, A3: 4, AS2: 0, AS2: 0, }, to: { A2: 137, A3: -49, AS2: 0, AS2: 0.6 } } }

  function moveBridge(no, ABC, to = 25) {
   if (!no) no = labelInfo.gateClick;
   var i1 = bridge_code1.findIndex(x => x == no);
   var i2 = bridge_code2.findIndex(x => x == no);
   var i3 = bridge_code3.findIndex(x => x == no);

   var move = bridge_move;
   if (i3 > -1) move = bridge_move3;

   var m = null;
   if (i1 > -1) m = bridge_planeModel1[i1];
   if (i2 > -1) m = bridge_planeModel2[i2];
   if (i3 > -1) m = bridge_planeModel3[i3];

   const c = {};
   var pointsA = [];
   for (var i = 0; i < to; i++) {
    for (const key in move[m].from) {
     c[key] = move[m].from[key] + (i / 25) * (move[m].to[key] - move[m].from[key]);
    }
    if (ABC == 'A') {
     pointsA.push({
      A2: c.A2, A3: c.A3,
      AS2: c.AS2, AS3: c.AS3
     })
    }
    if (ABC == 'B') {
     pointsA.push({
      B2: c.B2, B3: c.B3,
      BS2: c.BS2, BS3: c.BS3
     })
    }
    if (ABC == 'C') {
     pointsA.push({
      C2: c.C2, C3: c.C3,
      CS2: c.CS2, CS3: c.CS3
     })
    }
   }
   if (i1 > -1) {
    if (ABC == 'A') bridgeMove1A[i1] = { points: pointsA, current: 0 };
    if (ABC == 'B') bridgeMove1B[i1] = { points: pointsA, current: 0 };
    if (ABC == 'C') bridgeMove1C[i1] = { points: pointsA, current: 0 };
   }

   if (i2 > -1) {
    if (ABC == 'A') bridgeMove2A[i2] = { points: pointsA, current: 0 };
    if (ABC == 'B') bridgeMove2B[i2] = { points: pointsA, current: 0 };
    if (ABC == 'C') bridgeMove2C[i2] = { points: pointsA, current: 0 };
   }

   if (i3 > -1) {
    if (ABC == 'A') bridgeMove3A[i3] = { points: pointsA, current: 0 };
   }
  }


  function removeBridge(no, ABC) {
   if (!no) no = labelInfo.gateClick;
   var i1 = bridge_code1.findIndex(x => x == no);
   var i2 = bridge_code2.findIndex(x => x == no);
   var i3 = bridge_code3.findIndex(x => x == no);

   const c = {};
   var pointsA = [];

   var move = bridge_move;
   if (i3 > -1) move = bridge_move3;


   var m = null;
   if (i1 > -1) m = bridge_planeModel1[i1];
   if (i2 > -1) m = bridge_planeModel2[i2];
   if (i3 > -1) m = bridge_planeModel3[i3];

   for (var i = 25; i > 0; i--) {
    for (const key in move[m].from) {
     c[key] = move[m].from[key] + (i / 25) * (move[m].to[key] - move[m].from[key]);
    }
    if (ABC == 'A') {
     pointsA.push({
      A2: c.A2, A3: c.A3,
      AS2: c.AS2, AS3: c.AS3
     })
    }
    if (ABC == 'B') {
     pointsA.push({
      B2: c.B2, B3: c.B3,
      BS2: c.BS3, BS3: c.BS3
     })
    }
    if (ABC == 'C') {
     pointsA.push({
      C2: c.C2, C3: c.C3,
      CS2: c.CS2, CS3: c.CS3
     })
    }
   }
   if (i1 > -1) {
    if (ABC == 'A') bridgeMove1A[i1] = { points: pointsA, current: 0 };
    if (ABC == 'B') bridgeMove1B[i1] = { points: pointsA, current: 0 };
    if (ABC == 'C') bridgeMove1C[i1] = { points: pointsA, current: 0 };
   }

   if (i2 > -1) {
    if (ABC == 'A') bridgeMove2A[i2] = { points: pointsA, current: 0 };
    if (ABC == 'B') bridgeMove2B[i2] = { points: pointsA, current: 0 };
    if (ABC == 'C') bridgeMove2C[i2] = { points: pointsA, current: 0 };
   }

   if (i3 > -1) {
    if (ABC == 'A') bridgeMove3A[i3] = { points: pointsA, current: 0 };
   }
  }


  //清除飛機
  function clearPlane(no) {
   var i1 = bridge_code1.findIndex(x => x == no);
   var i2 = bridge_code2.findIndex(x => x == no);
   var i3 = bridge_code3.findIndex(x => x == no);
   if (i1 > -1) {
    bridge_planeModel1[i1] = '';
    var p1 = bridge1[i1].findIndex(x => x.obj_type == 'plane');
    if (p1 > -1) {
     scene.remove(bridge1[i1][p1]);
     bridge1[i1].splice(p1, 1);
    }
   }
   else if (i2 > -1) {
    bridge_planeModel2[i2] = '';
    var p2 = bridge2[i2].findIndex(x => x.obj_type == 'plane');
    if (p2 > -1) {
     scene.remove(bridge2[i2][p2]);
     bridge2[i2].splice(p2, 1);
    }
   }
   else if (i3 > -1) {
    bridge_planeModel3[i3] = '';
    var p3 = bridge3[i3].findIndex(x => x.obj_type == 'plane');
    if (p3 > -1) {
     scene.remove(bridge3[i3][p3]);
     bridge3[i3].splice(p3, 1);
    }
   }
  }

  //
  function rotateBridge(tmp, stlModels, c, N, A2, A4, SA3, SA4, xOffset = 0, xIncrement = 0, zOffset = 0, zIncrement = 0) {

   //找原始設定
   if (!tmp) return;
   var idxA1 = JSON.parse(JSON.stringify(tmp[tmp.findIndex(x => x.obj_type && x.obj_type == N + '1')]));
   var idxA2 = JSON.parse(JSON.stringify(tmp[tmp.findIndex(x => x.obj_type && x.obj_type == N + '2')]));
   var idxA3 = JSON.parse(JSON.stringify(tmp[tmp.findIndex(x => x.obj_type && x.obj_type == N + '3')]));
   var idxA4 = JSON.parse(JSON.stringify(tmp[tmp.findIndex(x => x.obj_type && x.obj_type == N + '4')]));

   var idxAL1 = JSON.parse(JSON.stringify(tmp[tmp.findIndex(x => x.obj_type && x.obj_type == N + 'L1')]));
   var idxAL2 = JSON.parse(JSON.stringify(tmp[tmp.findIndex(x => x.obj_type && x.obj_type == N + 'L2')]));
   var idxAL3 = JSON.parse(JSON.stringify(tmp[tmp.findIndex(x => x.obj_type && x.obj_type == N + 'L3')]));

   var stlModel1 = stlModels[stlModels.findIndex(x => x.obj_type && x.obj_type == N + '1')];
   var stlModel2 = stlModels[stlModels.findIndex(x => x.obj_type && x.obj_type == N + '2')];
   var stlModel3 = stlModels[stlModels.findIndex(x => x.obj_type && x.obj_type == N + '3')];
   var stlModel4 = stlModels[stlModels.findIndex(x => x.obj_type && x.obj_type == N + '4')];
   var stlModelL2 = stlModels[stlModels.findIndex(x => x.obj_type && x.obj_type == N + 'L2')];
   var stlModelL3 = stlModels[stlModels.findIndex(x => x.obj_type && x.obj_type == N + 'L3')];


   var centerA2 = idxA2.center;
   var centerA3 = idxA3.center;
   var centerA4 = idxA4.center;
   var rotateA1 = idxA1.rotation;
   var rotateA2 = idxA2.rotation;
   var rotateA3 = idxA3.rotation;
   var rotateA4 = idxA4.rotation;
   var posA1 = idxA1.position;
   var posA2 = idxA2.position;
   var posA3 = idxA3.position;
   var posAL2 = idxAL2.position;
   var posAL3 = idxAL3.position;
   var posA4 = idxA4.position;
   var scaleA1 = idxA1.scale;
   var scaleA2 = idxA2.scale;
   var scaleA3 = idxA3.scale;
   var scaleA4 = idxA4.scale;




   var newPosA2 = rotatePoint(posA2.x, posA2.y, posA2.z, centerA2.x, centerA2.y, centerA2.z, 0, A2, 0);
   idxA2.rotation = { _x: 0, _y: A2 / 180 * Math.PI, _z: 0 };
   idxA2.position = { x: newPosA2.x, y: newPosA2.y, z: newPosA2.z };


   var newPosA3 = rotatePoint(posA3.x, posA3.y, posA3.z + SA3, centerA2.x, centerA2.y, centerA2.z, 0, A2, 0);
   idxA3.rotation = { _x: 0, _y: A2 / 180 * Math.PI, _z: 0 };
   idxA3.position = { x: newPosA3.x, y: newPosA3.y, z: newPosA3.z };

   var newPosA4 = rotatePoint(posA4.x, posA4.y, posA4.z + SA3, centerA2.x, centerA2.y, centerA2.z, 0, A2, 0);
   idxA4.rotation = { _x: 0, _y: (A2 + A4) / 180 * Math.PI, _z: 0 };
   idxA4.position = { x: newPosA4.x, y: newPosA4.y, z: newPosA4.z };


   var newPosAL2 = rotatePoint(posAL2.x, posAL2.y, posAL2.z, centerA2.x, centerA2.y, centerA2.z, 0, A2, 0);
   idxAL2.position = { x: newPosAL2.x, y: newPosAL2.y, z: newPosAL2.z };


   var newPosAL3 = rotatePoint(posAL3.x, posAL3.y, posAL3.z + SA3, centerA2.x, centerA2.y, centerA2.z, 0, A2, 0);
   idxAL3.position = { x: newPosAL3.x, y: newPosAL3.y, z: newPosAL3.z };


   var newCenterA4 = rotatePoint(centerA4.x, centerA4.y, centerA4.z + SA3, centerA2.x, centerA2.y, centerA2.z, 0, A2, 0);

   newPosA4 = rotatePoint(newPosA4.x, newPosA4.y, newPosA4.z, newCenterA4.x, newCenterA4.y, newCenterA4.z, rotateA4._x * 180 / Math.PI, A4, rotateA4._z * 180 / Math.PI);

   idxA4.position = { x: newPosA4.x, y: newPosA4.y, z: newPosA4.z };
   idxA4.scale = { x: 0.35, y: 0.35, z: SA4 };

   stlModel2.rotation.set(idxA2.rotation._x, idxA2.rotation._y, idxA2.rotation._z);
   stlModel3.rotation.set(idxA3.rotation._x, idxA3.rotation._y, idxA3.rotation._z);
   stlModel4.rotation.set(idxA4.rotation._x, idxA4.rotation._y, idxA4.rotation._z);
   stlModel2.position.set(idxA2.position.x + xOffset + c * xIncrement, idxA2.position.y, idxA2.position.z - zOffset - c * zIncrement);
   stlModel3.position.set(idxA3.position.x + xOffset + c * xIncrement, idxA3.position.y, idxA3.position.z - zOffset - c * zIncrement);
   stlModel4.position.set(idxA4.position.x + xOffset + c * xIncrement, idxA4.position.y, idxA4.position.z - zOffset - c * zIncrement);
   stlModelL2.position.set(idxAL2.position.x + xOffset + c * xIncrement, idxAL2.position.y, idxAL2.position.z - zOffset - c * zIncrement);
   stlModelL3.position.set(idxAL3.position.x + xOffset + c * xIncrement, idxAL3.position.y, idxAL3.position.z - zOffset - c * zIncrement);
   stlModel4.scale.set(0.35, 0.35, SA4);
  }


  // 创建带有斜体文字和斜斜的长方形的画布
  function createA380TextTexture() {
   const canvas = document.createElement('canvas');
   const context = canvas.getContext('2d');
   canvas.width = 512;
   canvas.height = 512;
   context.fillStyle = 'white';
   context.fillRect(0, 0, canvas.width, canvas.height);
   context.fillStyle = 'black';
   context.font = 'italic bold 140px Arial'; // 设置斜体和粗体

   // 绘制斜斜的长方形
   context.save();
   context.translate(canvas.width / 2, canvas.height / 2);
   context.rotate(-Math.PI / 2); // 45度角
   context.fillStyle = 'red';
   context.fillRect(-canvas.width, -30, canvas.width * 2, 60); // 第一条
   context.fillStyle = 'blue';
   context.fillRect(-canvas.width, -90, canvas.width * 2, 60); // 第二条
   context.restore();

   // 填满整个画布的斜体粗体文字
   for (let y = 0; y < canvas.height; y += 500) { // 100 是字体高度和行间距的总和
    for (let x = 0; x < canvas.width; x += 300) { // 200 是大致的文字宽度
     context.save();
     context.translate(x, y + 48);
     context.rotate(-Math.PI / 2); // 45度角
     context.fillText('A380', 0, 0);
     context.restore();
    }
   }

   const texture = new THREE.CanvasTexture(canvas);
   texture.wrapS = THREE.RepeatWrapping;
   texture.wrapT = THREE.RepeatWrapping;
   texture.repeat.set(4, 4); // 调整重复次数，根据需要调整
   return texture;
  }

  function createA350900TextTexture() {
   const canvas = document.createElement('canvas');
   const context = canvas.getContext('2d');
   canvas.width = 512;
   canvas.height = 512;
   context.fillStyle = 'white';
   context.fillRect(0, 0, canvas.width, canvas.height);
   context.fillStyle = 'black';
   context.font = 'italic bold 140px Times New Roman';
   context.save();
   context.translate(canvas.width / 2, canvas.height / 2);
   context.rotate(-Math.PI / 2);
   context.fillStyle = 'purple';
   context.fillRect(-canvas.width, -40, canvas.width * 2, 80);
   context.fillStyle = 'orange';
   context.fillRect(-canvas.width, -120, canvas.width * 2, 80);
   context.restore();
   for (let y = 0; y < canvas.height; y += 500) {
    for (let x = 0; x < canvas.width; x += 300) {
     context.save();
     context.translate(x, y + 72);
     context.rotate(-Math.PI / 2);
     context.fillText('A350-900', 0, 0);
     context.restore();
    }
   }
   const texture = new THREE.CanvasTexture(canvas);
   texture.wrapS = THREE.RepeatWrapping;
   texture.wrapT = THREE.RepeatWrapping;
   texture.repeat.set(4, 4);
   return texture;
  }

  function createA330300TextTexture() {
   const canvas = document.createElement('canvas');
   const context = canvas.getContext('2d');
   canvas.width = 512;
   canvas.height = 512;
   context.fillStyle = 'white';
   context.fillRect(0, 0, canvas.width, canvas.height);
   context.fillStyle = 'black';
   context.font = 'italic bold 140px Verdana';
   context.save();
   context.translate(canvas.width / 2, canvas.height / 2);
   context.rotate(-Math.PI / 2);
   context.fillStyle = 'red';
   context.fillRect(-canvas.width, -30, canvas.width * 2, 60);
   context.fillStyle = 'blue';
   context.fillRect(-canvas.width, -90, canvas.width * 2, 60);
   context.restore();
   for (let y = 0; y < canvas.height; y += 500) {
    for (let x = 0; x < canvas.width; x += 300) {
     context.save();
     context.translate(x, y + 48);
     context.rotate(-Math.PI / 2);
     context.fillText('A330-300', 0, 0);
     context.restore();
    }
   }
   const texture = new THREE.CanvasTexture(canvas);
   texture.wrapS = THREE.RepeatWrapping;
   texture.wrapT = THREE.RepeatWrapping;
   texture.repeat.set(4, 4);
   return texture;
  }

  function createA321neoTextTexture() {
   const canvas = document.createElement('canvas');
   const context = canvas.getContext('2d');
   canvas.width = 512;
   canvas.height = 512;
   context.fillStyle = 'white';
   context.fillRect(0, 0, canvas.width, canvas.height);
   context.fillStyle = 'darkblue';
   context.font = 'italic bold 140px Georgia';
   context.save();
   context.translate(canvas.width / 2, canvas.height / 2);
   context.rotate(-Math.PI / 2);
   context.fillStyle = 'lightblue';
   context.fillRect(-canvas.width, -50, canvas.width * 2, 100);
   context.fillStyle = 'green';
   context.fillRect(-canvas.width, -150, canvas.width * 2, 100);
   context.restore();
   for (let y = 0; y < canvas.height; y += 500) {
    for (let x = 0; x < canvas.width; x += 300) {
     context.save();
     context.translate(x, y + 48);
     context.rotate(-Math.PI / 2);
     context.fillText('A321neo', 0, 0);
     context.restore();
    }
   }
   const texture = new THREE.CanvasTexture(canvas);
   texture.wrapS = THREE.RepeatWrapping;
   texture.wrapT = THREE.RepeatWrapping;
   texture.repeat.set(4, 4);
   return texture;
  }



  function create78710TextTexture() {
   const canvas = document.createElement('canvas');
   const context = canvas.getContext('2d');
   canvas.width = 512;
   canvas.height = 512;
   context.fillStyle = 'white';
   context.fillRect(0, 0, canvas.width, canvas.height);
   context.fillStyle = 'black';
   context.font = 'italic bold 140px Arial';
   context.save();
   context.translate(canvas.width / 2, canvas.height / 2);
   context.rotate(-Math.PI / 2);
   context.fillStyle = 'red';
   context.fillRect(-canvas.width, -30, canvas.width * 2, 60);
   context.fillStyle = 'blue';
   context.fillRect(-canvas.width, -90, canvas.width * 2, 60);
   context.restore();
   for (let y = 0; y < canvas.height; y += 500) {
    for (let x = 0; x < canvas.width; x += 300) {
     context.save();
     context.translate(x, y + 48);
     context.rotate(-Math.PI / 2);
     context.fillText('787-10', 0, 0);
     context.restore();
    }
   }
   const texture = new THREE.CanvasTexture(canvas);
   texture.wrapS = THREE.RepeatWrapping;
   texture.wrapT = THREE.RepeatWrapping;
   texture.repeat.set(4, 4);
   return texture;
  }

  function create777300ERTextTexture() {
   const canvas = document.createElement('canvas');
   const context = canvas.getContext('2d');
   canvas.width = 512;
   canvas.height = 512;
   context.fillStyle = 'white';
   context.fillRect(0, 0, canvas.width, canvas.height);
   context.fillStyle = 'darkgreen';
   context.font = 'italic bold 140px Courier New';
   context.save();
   context.translate(canvas.width / 2, canvas.height / 2);
   context.rotate(-Math.PI / 2);
   context.fillStyle = 'lightblue';
   context.fillRect(-canvas.width, -30, canvas.width * 2, 60);
   context.fillStyle = 'red';
   context.fillRect(-canvas.width, -90, canvas.width * 2, 60);
   context.restore();
   for (let y = 0; y < canvas.height; y += 500) {
    for (let x = 0; x < canvas.width; x += 300) {
     context.save();
     context.translate(x, y + 48);
     context.rotate(-Math.PI / 2);
     context.fillText('777-300ER', 0, 0);
     context.restore();
    }
   }
   const texture = new THREE.CanvasTexture(canvas);
   texture.wrapS = THREE.RepeatWrapping;
   texture.wrapT = THREE.RepeatWrapping;
   texture.repeat.set(4, 4);
   return texture;
  }


  function create747400FTextTexture() {
   const canvas = document.createElement('canvas');
   const context = canvas.getContext('2d');
   canvas.width = 512;
   canvas.height = 512;
   context.fillStyle = 'white';
   context.fillRect(0, 0, canvas.width, canvas.height);
   context.fillStyle = 'black';
   context.font = 'italic bold 140px Arial';
   context.save();
   context.translate(canvas.width / 2, canvas.height / 2);
   context.rotate(-Math.PI / 2);
   context.fillStyle = 'blue';
   context.fillRect(-canvas.width, -30, canvas.width * 2, 60);
   context.fillStyle = 'red';
   context.fillRect(-canvas.width, -90, canvas.width * 2, 60);
   context.restore();
   for (let y = 0; y < canvas.height; y += 500) {
    for (let x = 0; x < canvas.width; x += 300) {
     context.save();
     context.translate(x, y + 48);
     context.rotate(-Math.PI / 2);
     context.fillText('747-400F', 0, 0);
     context.restore();
    }
   }
   const texture = new THREE.CanvasTexture(canvas);
   texture.wrapS = THREE.RepeatWrapping;
   texture.wrapT = THREE.RepeatWrapping;
   texture.repeat.set(4, 4);
   return texture;
  }

  function create737800TextTexture() {
   const canvas = document.createElement('canvas');
   const context = canvas.getContext('2d');
   canvas.width = 512;
   canvas.height = 512;
   context.fillStyle = 'white';
   context.fillRect(0, 0, canvas.width, canvas.height);
   context.fillStyle = 'black';
   context.font = 'italic bold 140px Arial';
   context.save();
   context.translate(canvas.width / 2, canvas.height / 2);
   context.rotate(-Math.PI / 2);
   context.fillStyle = 'yellow';
   context.fillRect(-canvas.width, -30, canvas.width * 2, 60);
   context.fillStyle = 'purple';
   context.fillRect(-canvas.width, -90, canvas.width * 2, 60);
   context.restore();
   for (let y = 0; y < canvas.height; y += 500) {
    for (let x = 0; x < canvas.width; x += 300) {
     context.save();
     context.translate(x, y + 48);
     context.rotate(-Math.PI / 2);
     context.fillText('737-800', 0, 0);
     context.restore();
    }
   }
   const texture = new THREE.CanvasTexture(canvas);
   texture.wrapS = THREE.RepeatWrapping;
   texture.wrapT = THREE.RepeatWrapping;
   texture.repeat.set(4, 4);
   return texture;
  }

  // 手动生成简单的UV坐标
  function generateUVs(geometry) {
   const position = geometry.attributes.position;
   const uvArray = new Float32Array(position.count * 2);
   const boundingBox = geometry.boundingBox;
   const size = new THREE.Vector3();
   boundingBox.getSize(size);

   for (let i = 0; i < position.count; i++) {
    const x = position.getX(i);
    const y = position.getY(i);
    const z = position.getZ(i);

    // 使用x和z坐标来生成uv（可以根据需要调整）
    uvArray[i * 2] = (x - boundingBox.min.x) / size.x;
    uvArray[i * 2 + 1] = (z - boundingBox.min.z) / size.z;
   }

   geometry.setAttribute('uv', new THREE.BufferAttribute(uvArray, 2));
  }

  //增加模型
  function addModel(_objCollect, labelData, geometry, c, color, m) {
   const loader = new STLLoader();

   var geo = geometry.clone();
   geo.computeBoundingBox();
   geo.computeVertexNormals();

   generateUVs(geo);

   var texture = null;
   if (m == 'A380') texture = createA380TextTexture();
   if (m == 'A350-900') texture = createA350900TextTexture();
   if (m == 'A330-300') texture = createA330300TextTexture();
   if (m == 'A321neo') texture = createA321neoTextTexture();
   if (m == '787-10') texture = create78710TextTexture();
   if (m == '777-300ER') texture = create777300ERTextTexture();
   if (m == '747-400F') texture = create747400FTextTexture();
   if (m == '737-800') texture = create737800TextTexture();
   // 设置纹理重复和包裹
   texture.wrapS = THREE.RepeatWrapping;
   texture.wrapT = THREE.RepeatWrapping;
   texture.repeat.set(10, 10);  // 调整重复次数

   var material = new THREE.MeshPhongMaterial({
    color: color, shininess: 300, // 提高高光强度
    specular: new THREE.Color(0xeeeeee), // 设置高光颜色为白色
    map: texture
   });  //new THREE.MeshBasicMaterial({ color: color });
   var stlModel = new THREE.Mesh(geo, material);
   stlModel.obj_name = name;
   stlModel.obj_type = 'plane';
   stlModel.transparent = true;
   stlModel.opacity = 0;
   if (labelData) stlModel.label = labelData[c];
   scene.add(stlModel);
   _objCollect[c].push(stlModel);
  }

  function setBridgeCamera(no) {
   if (!no) no = labelInfo.gateClick;
   let sumX = 0, sumY = 0, sumZ = 0;
   let count = 0;

   scene.traverse(function (object) {
    if (object.isMesh && object.label && object.label == no) {
     sumX += object.position.x;
     sumY += object.position.y;
     sumZ += object.position.z;
     count++;
    }
   });

   const centerX = sumX / count;
   const centerY = sumY / count;
   const centerZ = sumZ / count;
   // 设置摄像机看向新的中心点

   // 设置摄像机位置
   const cameraDistance = 50; // 摄像机与目标点的距离
   const cameraHeight = 50; // 摄像机的高度
   camera.position.set(centerX, centerY + cameraHeight, centerZ);

   // 计算摄像机指向目标点的方向向量
   const direction = new THREE.Vector3(centerX, centerY, centerZ).sub(camera.position).normalize();

   // 设置摄像机的方向
   camera.lookAt(new THREE.Vector3(centerX, centerY, centerZ));
   camera.up.set(0, 1, 0); // 设置摄像机的上方向为正上方

   // 将摄像机方向旋转90度
   camera.rotateX(-Math.PI / 2);

   // 更新控制器的目标点到摄像机所在位置的正上方
   controls.target.set(centerX, 0, centerZ);

   // 更新摄像机的投影矩阵
   camera.updateProjectionMatrix();

  }


  function setLabelData(id, data) {
   if (document.getElementById(id)) document.getElementById(id).innerHTML = data;
  }

  function setLabelDataColor(id, data) {
   if (document.getElementById(id)) document.getElementById(id).style.backgroundColor = data;
  }

  function setLabelVisible(id, data) {
   if (document.getElementById(id)) document.getElementById(id).style.visibility = data ? 'hidden' : 'visible';
  }

  function setPlaneData(no, data) {
   if (document.getElementById(no + "_plane")) document.getElementById(no + "_plane").innerHTML = data;
  }

  function setPlaneDataColor(no, data) {
   if (document.getElementById(no + "_plane")) document.getElementById(no + "_plane").style.backgroundColor = data;
  }

  function setWindData(no, data) {
   if (document.getElementById(no + "_wind")) document.getElementById(no + "_wind").innerText = data;
  }

  function setWindDataColor(no, data) {
   if (document.getElementById(no + "_wind")) document.getElementById(no + "_wind").style.backgroundColor = data;
  }
  function clearLabelFlash(id) {
   if (document.getElementById(id)) {
    document.getElementById(id).style.visibility = 'visible';
    if (_collect_intervalId[`id_${id}`]) {
     clearInterval(_collect_intervalId[`id_${id}`]);
     _collect_intervalId[`id_${id}`] = false;
    }
   }
  }

  function setLabelFlash(id) {
   if (_collect_intervalId[`id_${id}`]) return;
   _collect_intervalId[`id_${id}`] = setInterval(function (id) {
    document.getElementById(id).style.visibility = document.getElementById(id).style.visibility == 'hidden' ? 'visible' : 'hidden';
   }, 500, id); // 设置闪烁间隔（毫秒）
  }

  function clearFlash(no, b, i) {
   setVisible(no, b, i, false, false);
   if (_collect_intervalId[`${no}_${b}_${i}`]) {
    clearInterval(_collect_intervalId[`${no}_${b}_${i}`]);
    _collect_intervalId[`${no}_${b}_${i}`] = false;
   }
  }

  function setFlash(no, b, i) {
   if (_collect_intervalId[`${no}_${b}_${i}`]) return;
   _collect_intervalId[`${no}_${b}_${i}`] = setInterval(function (no, b, i) {
    setVisible(no, b, i, null, true);
   }, 500, no, b, i); // 设置闪烁间隔（毫秒）
  }


  function setVisible(no, b, i, isHidden, reverse) {
   const _bridges = [bridge1, bridge2, bridge3];
   const _bridgeCodes = [bridge_code1, bridge_code2, bridge_code3];

   for (let j = 0; j < _bridgeCodes.length; j++) {
    const _index = _bridgeCodes[j].findIndex(x => x == no);
    if (_index > -1) {
     const _bridge = _bridges[j];
     const _types = ['L', 'LA', 'LB', 'LC', `AL${i}`, `BL${i}`, `CL${i}`];
     for (let k = 0; k < _types.length; k++) {
      const _type = _types[k];
      let p;
      if (b == null && i == null) {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      } else if (b != null && b.indexOf("_A") > -1 && i == null && _type == 'LA') {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      } else if (b != null && b.indexOf("_B") > -1 && i == null && _type == 'LB') {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      } else if (b != null && b.indexOf("_C") > -1 && i == null && _type == 'LC') {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      } else if (b != null && b.indexOf("_A") > -1 && i != null && _type == `AL${i}`) {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      } else if (b != null && b.indexOf("_B") > -1 && i != null && _type == `BL${i}`) {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      } else if (b != null && b.indexOf("_C") > -1 && i != null && _type == `CL${i}`) {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      }
      if (p > -1) {
       if (reverse) {
        isHidden = !_bridge[_index][p].material.transparent;
       }

       if (isHidden) {
        _bridge[_index][p].material.transparent = true;
        _bridge[_index][p].material.opacity = 0;
       }
       else {
        _bridge[_index][p].material.transparent = false;
        _bridge[_index][p].material.opacity = 1;
       }
       break;

      }
     }
     break;
    }
   }
  }



  function setColor(no, b, i, c) {

   const _bridges = [bridge1, bridge2, bridge3];
   const _bridgeCodes = [bridge_code1, bridge_code2, bridge_code3];

   for (let j = 0; j < _bridgeCodes.length; j++) {
    const _index = _bridgeCodes[j].findIndex(x => x == no);
    if (_index > -1) {
     const _bridge = _bridges[j];
     const _types = ['L', 'LA', 'LB', 'LC', `AL${i}`, `BL${i}`, `CL${i}`];
     for (let k = 0; k < _types.length; k++) {
      const _type = _types[k];
      let p;
      if (b == null && i == null) {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      } else if (b != null && b.indexOf("_A") > -1 && i == null && _type == 'LA') {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      } else if (b != null && b.indexOf("_B") > -1 && i == null && _type == 'LB') {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      } else if (b != null && b.indexOf("_C") > -1 && i == null && _type == 'LC') {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      } else if (b != null && b.indexOf("_A") > -1 && i != null && _type == `AL${i}`) {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      } else if (b != null && b.indexOf("_B") > -1 && i != null && _type == `BL${i}`) {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      } else if (b != null && b.indexOf("_C") > -1 && i != null && _type == `CL${i}`) {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      }
      if (p > -1) {
       _bridge[_index][p].material.color.set(c);
       break;

      }
     }
     break;
    }
   }
  }


  function setBridgeVisible(no, abc, isHidden) {
   var i1 = bridge_code1.findIndex(x => x == no);
   var i2 = bridge_code2.findIndex(x => x == no);
   var i3 = bridge_code3.findIndex(x => x == no);
   if (i1 > -1) {
    bridge1[i1].forEach(element => {
     if ((abc == "A" && element.obj_type && element.obj_type.indexOf("A") == 0) ||
      (abc == "B" && element.obj_type && element.obj_type.indexOf("B") == 0) ||
      (abc == "C" && element.obj_type && element.obj_type.indexOf("C") == 0)) {
      element.material.transparent = isHidden;
      element.material.opacity = isHidden ? 0 : 1;
     }
    });
   }
   else if (i2 > -1) {
    bridge2[i2].forEach(element => {
     if ((abc == "A" && element.obj_type && element.obj_type.indexOf("A") == 0) ||
      (abc == "B" && element.obj_type && element.obj_type.indexOf("B") == 0) ||
      (abc == "C" && element.obj_type && element.obj_type.indexOf("C") == 0)) {
      element.material.transparent = isHidden;
      element.material.opacity = isHidden ? 0 : 1;
     }
    });
   }
   else if (i3 > -1) {
    bridge3[i3].forEach(element => {
     if ((abc == "A" && element.obj_type && element.obj_type.indexOf("A") == 0) ||
      (abc == "B" && element.obj_type && element.obj_type.indexOf("B") == 0) ||
      (abc == "C" && element.obj_type && element.obj_type.indexOf("C") == 0)) {
      element.material.transparent = isHidden;
      element.material.opacity = isHidden ? 0 : 1;
     }
    });
   }
  }
  //載入模型
  function loadPlaneModels(promises) {
   planeData.forEach((item, index) => {
    const promise = new Promise((resolve, reject) => {
     if (item.name.indexOf('.stl') > -1) {
      const loader = new STLLoader();
      loader.load(item.name, function (geometry) {
       _objPlaneCollect[index] = geometry; // 使用 index 存储 geometry
       resolve();
      }, undefined, function (error) {
       console.error('Error loading STL file:', error);
       reject(error);
      });
     } else {
      resolve();
     }
    });
    promises.push(promise);
   });
  }

  function loadModels(promises, _objCollect, labelData, tmpData, xOffset = 0, xIncrement = 0, zOffset = 0, zIncrement = 0, reflectivity = 1, emissive = '#000000', transparent = false, opacity = 1) {

   for (let c = 0; c < _objCollect.length; c++) {
    tmpData.forEach((item, i) => {
     const promise = new Promise((resolve, reject) => {
      if (item.name.indexOf('.stl') > -1) {
       const loader = new STLLoader();
       loader.load(item.name, function (geometry) {
        if (xOffset == -100000)  //飛機
        {
         _objCollect[c] = geometry;
         resolve();
         return;
        }

        geometry.computeBoundingBox();
        geometry.computeVertexNormals();
        generateUVs(geometry);
        var material = new THREE.MeshToonMaterial({ color: item.color, reflectivity: reflectivity, emissive: emissive });
        var stlModel = new THREE.Mesh(geometry, material);

        if (item.obj_type == "ground") {
         var textureLoader = new THREE.TextureLoader();
         var texture = textureLoader.load('T3.gif', function (imageTexture) {

          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          const size = 512; // 假设图像是正方形的
          canvas.width = size;
          canvas.height = size;

          // 旋转画布
          context.translate(size / 2, size / 2);
          context.rotate(Math.PI / 2);
          context.drawImage(imageTexture.image, -size / 2, -size / 2, size, size);

          const rotatedTexture = new THREE.CanvasTexture(canvas);
          rotatedTexture.wrapS = THREE.ClampToEdgeWrapping;
          rotatedTexture.wrapT = THREE.ClampToEdgeWrapping;
          rotatedTexture.minFilter = THREE.LinearFilter;
          rotatedTexture.magFilter = THREE.LinearFilter;

          var planeMaterial = new THREE.MeshLambertMaterial({ map: rotatedTexture });

          stlModel.material = planeMaterial;
          stlModel.material.needsUpdate = true;

         });

        }

        stlModel.obj_name = item.name;
        if (item.obj_type != '') stlModel.obj_type = item.obj_type;
        if (labelData) stlModel.label = labelData[c];
        scene.add(stlModel);
        // 設置模型位置、縮放和旋轉

        if (item.center) {
         stlModel.rotation.set(
          item.rotation._x,
          item.rotation._y,
          item.rotation._z
         );
         var newPos = rotatePoint(item.position.x, item.position.y, item.position.z,
          item.center.x, item.center.y, item.center.z,
          item.rotation._x * 180 / Math.PI, item.rotation._y * 180 / Math.PI, item.rotation._z * 180 / Math.PI)

         // 在这个闭包内，i和item是被正确捕获的
         stlModel.position.set(newPos.x + xOffset + c * xIncrement, newPos.y, newPos.z - zOffset - c * zIncrement);
        }
        else {

         stlModel.rotation.set(
          item.rotation._x,
          item.rotation._y,
          item.rotation._z
         );
         // 在这个闭包内，i和item是被正确捕获的
         stlModel.position.set(item.position.x + xOffset + c * xIncrement, item.position.y, item.position.z - zOffset - c * zIncrement);
        }

        stlModel.scale.set(item.scale.x, item.scale.y, item.scale.z);

        _objCollect[c].push(stlModel);


        if (item.obj_type.indexOf('label') > -1 && labelData) {


         const _Div = document.createElement("div");
         _Div.id = labelData[c];
         _Div.style.padding = '3px';
         _Div.style.color = '#fff';
         _Div.style.fontSize = '12px';
         _Div.style.position = 'absolute';
         _Div.style.backgroundColor = 'rgba(25,25,25,0.5)';
         _Div.style.borderRadius = '3px';
         _Div.className = "label";
         _Div.textContent = labelData[c];
         _Div.style.marginTop = "-1em";
         if (labelData) _Div.label = labelData[c];
         _Div.obj_type = item.obj_type;

         _Div.addEventListener('mouseover', function () {
          // 滑鼠移到登機門圖示錨點
          // _Div.style.background = 'lightblue'; // 鼠标悬停时改变背景颜色
          labelInfo.bridgeMouseover = "None";
          labelInfo.gateMouseover = labelData[c]; // 更新 GUI 显示的标签信息
          gui.updateDisplay(); // 更新 GUI 显示
         });
         _Div.addEventListener('mouseout', function (e) {
          // labelInfo.gateMouseover = "None";
          // labelInfo.gateClick = "None";
          //_Div.style.background = 'rgba(25,25,25,0.5)'; // 鼠标离开时恢复背景颜色
         });

         _Div.style.pointerEvents = 'auto';
         _Div.addEventListener('click', function (e) {
          // 所以無法click 
         }, false);

         const _Label = new CSS2DObject(_Div);
         _Label.position.set(-3, 20, 10);
         stlModel.add(_Label);



         const _Div2 = document.createElement("div");
         _Div2.id = labelData[c] + "_wind";
         _Div2.style.padding = '3px';
         _Div2.style.color = '#fff';
         _Div2.style.fontSize = '12px';
         _Div2.style.position = 'absolute';
         _Div2.style.backgroundColor = 'rgba(25,25,25,0.5)';
         _Div2.style.borderRadius = '3px';
         _Div2.className = "label wind";
         _Div2.textContent = "10 / 20";
         _Div2.style.marginTop = "-1em";
         if (labelData) _Div2.label = labelData[c];


         const _Label2 = new CSS2DObject(_Div2);
         _Label2.position.set(3, 20, 10);
         stlModel.add(_Label2);


         const _Div3 = document.createElement("div");
         _Div3.id = labelData[c] + "_plane";
         _Div3.style.padding = '3px';
         _Div3.style.color = '#fff';
         _Div3.style.fontSize = '12px';
         _Div3.style.position = 'absolute';
         _Div3.style.backgroundColor = 'rgba(25,25,25,0.5)';
         _Div3.style.borderRadius = '3px';
         _Div3.className = "label plane";
         _Div3.innerHTML = "C000  1234<br>抵達時間<br>離開時間";
         _Div3.style.marginTop = "-1em";
         if (labelData) _Div3.label = labelData[c];


         const _Label3 = new CSS2DObject(_Div3);
         _Label3.position.set(10, 20, 10);
         stlModel.add(_Label3);


         const _Div4 = document.createElement("div");
         _Div4.style.padding = '3px';
         _Div4.style.display = 'none';
         _Div4.className = "label fire";
         _Div4.innerHTML = '<img src=fire.gif class=fire />'
         if (labelData) _Div4.label = labelData[c];


         const _Label4 = new CSS2DObject(_Div4);
         _Label4.position.set(10, 20, 10);
         stlModel.add(_Label4);
        }

        resolve();
       });
      }
      else if (item.name.indexOf('light') > -1) {
       const pointLight = new THREE.PointLight(item.color, 1, 50); // 紅色光源
       pointLight.position.set(item.position.x + xOffset + c * xIncrement, item.position.y, item.position.z - zOffset - c * zIncrement); // 設定光源位置
       pointLight.obj_name = item.name;
       if (labelData) pointLight.label = labelData[c];
       scene.add(pointLight);
       _objCollect[c].push(pointLight);

       resolve();
      }
      else if (item.name.indexOf('sphere') > -1) {
       const sphereSize = 0.1;
       const bulbGeometry = new THREE.SphereGeometry(sphereSize, 16, 8);
       const bulbMaterial = new THREE.MeshBasicMaterial({ color: item.color }); // 與光源顏色相同
       const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
       bulb.position.set(item.position.x + xOffset + c * xIncrement, item.position.y, item.position.z - zOffset - c * zIncrement);  // 設置與光源相同的位置
       bulb.obj_name = item.name;
       if (item.obj_type != '') bulb.obj_type = item.obj_type;
       if (labelData) bulb.label = labelData[c];
       scene.add(bulb);
       _objCollect[c].push(bulb);


       if ((item.obj_type == "AL1" || item.obj_type == "BL1" || item.obj_type == "CL1") && labelData) {
        const _Div = document.createElement("div");
        _Div.id = labelData[c] + "_" + item.obj_type.replace("L1", "");
        _Div.style.padding = '3px';
        _Div.style.color = '#fff';
        _Div.style.fontSize = '12px';
        _Div.style.position = 'absolute';
        _Div.style.backgroundColor = 'rgba(25,25,25,0.5)';
        _Div.style.borderRadius = '3px';
        _Div.className = "label bridge";
        _Div.textContent = labelData[c] + "_" + item.obj_type.replace("L1", "");
        _Div.style.marginTop = "-1em";
        _Div.label = labelData[c] + "_" + item.obj_type.replace("L1", "");
        _Div.style.pointerEvents = 'auto';
        _Div.addEventListener('mouseover', function () {
         // 滑鼠移到登機門圖示錨點
         // _Div.style.background = 'lightblue'; // 鼠标悬停时改变背景颜色

         labelInfo.gateMouseover = "None";
         labelInfo.bridgeMouseover = labelData[c] + "_" + item.obj_type.replace("L1", ""); // 更新 GUI 显示的标签信息

         gui.updateDisplay(); // 更新 GUI 显示
        });
        _Div.addEventListener('mouseout', function (e) {
         //_Div.style.background = 'rgba(25,25,25,0.5)'; // 鼠标离开时恢复背景颜色
        });

        _Div.addEventListener('click', function (e) {
         // 所以無法click 
        }, false);

        const _Label = new CSS2DObject(_Div);
        _Label.position.set(-1, 0, 0);
        bulb.add(_Label);


       }

       if (item.obj_type == "AL1" || item.obj_type == "AL2" || item.obj_type == "AL3" ||
        item.obj_type == "BL1" || item.obj_type == "BL2" || item.obj_type == "BL3" ||
        item.obj_type == "CL1" || item.obj_type == "CL2" || item.obj_type == "CL3") {

        const _Div1 = document.createElement("div");
        _Div1.id = labelData[c] + "_" + item.obj_type + "_fire";
        _Div1.style.padding = '3px';
        _Div1.className = "label fire";
        _Div1.innerHTML = '<img src=fire.gif class=fire />'
        if (labelData) _Div1.label = labelData[c];
        const _Label1 = new CSS2DObject(_Div1);
        _Label1.position.set(-2, 0, 0);
        bulb.add(_Label1);
       }
       resolve();
      }

     });
     promises.push(promise);
    });
   }
  }

  function onMouseDown(event) {
   if (loading) return;
   // 计算鼠标在场景中的位置 
   mouse.x = (event.clientX / container.offsetWidth) * 2 - 1;
   mouse.y = -(event.clientY / container.offsetHeight) * 2 + 1;

   // 更新raycaster的射线方向
   raycaster.setFromCamera(mouse, camera);

   // 计算物体和射线的交点
   const intersects = raycaster.intersectObjects(scene.children);

   if (intersects.length > 0) {
    // 如果有物体被选中 
    var idx = intersects.findIndex(x => x.object.label);
    if (idx > -1) {
     labelInfo.modelClick = intersects[idx].object.label;
     gui.updateDisplay(); // 更新 GUI 显示

    }
   }
  }

  function onMouseDblClick(event) {
   if (loading) return;
   var bridge = null;
   var gate = null;


   var mouseX = event.clientX;
   var mouseY = event.clientY;
   var _2dObjs = document.getElementsByClassName('label'); // 假设你的 CSS2DObject 的 div 有 'label' 这个类
   Array.from(_2dObjs).forEach(_2dObj => {
    var rect = _2dObj.getBoundingClientRect(); // 获取元素的屏幕坐标边界

    if (mouseX >= rect.left && mouseX <= rect.right && mouseY >= rect.top && mouseY <= rect.bottom) {
     console.log('Clicked on label:', _2dObj);
     if (_2dObj.label == "label" || _2dObj.obj_type == "label") return;
     if (_2dObj.label == "building" || _2dObj.obj_type == "building") return;

     if (_2dObj.label && _2dObj.label.indexOf("_") == -1 && gate == null) {
      gate = _2dObj.label;
      labelInfo.gateDblClick = _2dObj.label;
     }
     if (_2dObj.label && _2dObj.label.indexOf("_") > -1 && bridge == null) {
      bridge = _2dObj.label;
      labelInfo.bridgeDblClick = _2dObj.label;
     }
     // 在这里执行你的逻辑
    }
   });


   // 计算鼠标在场景中的位置 
   mouse.x = (event.clientX / container.offsetWidth) * 2 - 1;
   mouse.y = -(event.clientY / container.offsetHeight) * 2 + 1;

   // 更新raycaster的射线方向
   raycaster.setFromCamera(mouse, camera);

   // 计算物体和射线的交点
   const intersects = raycaster.intersectObjects(scene.children);

   if (intersects.length > 0) {
    intersects.forEach(element => {
     if (element.object.label && element.object.obj_type == "label" && gate == null) {
      gate = element.object.label;
      labelInfo.gateDblClick = element.object.label;
     }
     if (element.object.obj_type && element.object.obj_type != "building" && bridge == null) {
      if (element.object.obj_type == "A1" || element.object.obj_type == "A2" || element.object.obj_type == "A3") {
       labelInfo.bridgeDblClick = element.object.label + "_A";
       bridge = labelInfo.bridgeDblClick;
      }
      if (element.object.obj_type == "B1" || element.object.obj_type == "B2" || element.object.obj_type == "B3") {
       labelInfo.bridgeDblClick = element.object.label + "_B";
       bridge = labelInfo.bridgeDblClick;
      }
      if (element.object.obj_type == "C1" || element.object.obj_type == "C2" || element.object.obj_type == "C3") {
       labelInfo.bridgeDblClick = element.object.label + "_C";
       bridge = labelInfo.bridgeDblClick;
      }
     }
     gui.updateDisplay(); // 更新 GUI 显示
    });
   }
   // 如果有物体被选中 
   if (bridge != null) {
    gui_bridge.domElement.style.display = 'block';
    gui.domElement.style.display = 'none';
    bimModel.style.visibility = 'hidden';
    bimModel.style.display = 'none';
    bimModel_bridge.style.visibility = 'visible';
    bimModel_bridge.style.display = 'block';
    // 使用者在空橋標籤或空橋錨點雙擊滑鼠，BIM Model 切換至空橋細部 
    enterBridgeId = labelInfo.bridgeDblClick;
    ap_didEnterBridgeScene(labelInfo.bridgeDblClick);
   }
  }
  var clicked = {};

  function onMouseClick(event) {
   if (loading) return;
   var gate = null;
   var bridge = null;

   var mouseX = event.clientX;
   var mouseY = event.clientY;
   var _2dObjs = document.getElementById("bimModel").getElementsByClassName('label'); // 假设你的 CSS2DObject 的 div 有 'label' 这个类
   Array.from(_2dObjs).forEach(_2dObj => {
    var rect = _2dObj.getBoundingClientRect(); // 获取元素的屏幕坐标边界

    if (mouseX >= rect.left && mouseX <= rect.right && mouseY >= rect.top && mouseY <= rect.bottom) {
     if (_2dObj.label && _2dObj.label.indexOf("_") == -1 && gate == null) {
      gate = _2dObj.label;
      labelInfo.gateClick = _2dObj.label;
     }
     if (_2dObj.label && _2dObj.label.indexOf("_") > -1 && bridge == null) {
      gate = _2dObj.label;
      labelInfo.bridgeClick = _2dObj.label;
     }
     // 在这里执行你的逻辑
    }
   });

   // 如果是2d
   if (gate != null && bridge == null) {
    if (!clicked[gate]) { clicked[gate] = 'Y'; ap_showBridgeInfo(gate); }
    return;
   }
   // 计算鼠标在场景中的位置 
   mouse.x = (event.clientX / container.offsetWidth) * 2 - 1;
   mouse.y = -(event.clientY / container.offsetHeight) * 2 + 1;

   // 更新raycaster的射线方向
   raycaster.setFromCamera(mouse, camera);

   // 计算物体和射线的交点
   const intersects = raycaster.intersectObjects(scene.children);

   if (intersects.length > 0) {
    // 如果有物体被选中 


    intersects.forEach(element => {
     if (element.object.label && element.object.obj_type == "label" && gate == null) {
      gate = element.object.label;
      labelInfo.gateClick = element.object.label;
     }
     if (element.object.obj_type && element.object.obj_type != "building" && bridge == null) {
      if (element.object.obj_type == "A1" || element.object.obj_type == "A2" || element.object.obj_type == "A3" || element.object.obj_type == "A4" ||
       element.object.obj_type == "AL1" || element.object.obj_type == "AL2" || element.object.obj_type == "AL3" || element.object.obj_type == "AL4") {
       labelInfo.bridgeClick = element.object.label + "_A";
       bridge = element.object.obj_type;
       gate = element.object.label;
       labelInfo.gateClick = element.object.label;
      }
      if (element.object.obj_type == "B1" || element.object.obj_type == "B2" || element.object.obj_type == "B3" || element.object.obj_type == "B4" ||
       element.object.obj_type == "BL1" || element.object.obj_type == "BL2" || element.object.obj_type == "BL3" || element.object.obj_type == "BL4") {
       labelInfo.bridgeClick = element.object.label + "_B";
       bridge = element.object.obj_type;
       gate = element.object.label;
       labelInfo.gateClick = element.object.label;
      }
      if (element.object.obj_type == "C1" || element.object.obj_type == "C2" || element.object.obj_type == "C3" || element.object.obj_type == "C4" ||
       element.object.obj_type == "CL1" || element.object.obj_type == "CL2" || element.object.obj_type == "CL3" || element.object.obj_type == "CL4") {
       labelInfo.bridgeClick = element.object.label + "_C";
       bridge = element.object.obj_type;
       gate = element.object.label;
       labelInfo.gateClick = element.object.label;
      }
     }

    });

   }
   if (gate != null && bridge == null) {
    if (!clicked[gate]) { clicked[gate] = 'Y'; ap_showBridgeInfo(gate); }
   }
   else if (gate != null && bridge != null) {
    if ((bridge == "A1" || bridge == "AL1") && !clicked[gate + "_A_0"]) { clicked[gate + "_A_0"] = 'Y'; ap_showBridgeDetailInfo(gate + "_A", 0); }
    else if ((bridge == "A2" || bridge == "AL1") && !clicked[gate + "_A_1"]) { clicked[gate + "_A_1"] = 'Y'; ap_showBridgeDetailInfo(gate + "_A", 1); }
    else if ((bridge == "A3" || bridge == "AL2") && !clicked[gate + "_A_1"]) { clicked[gate + "_A_1"] = 'Y'; ap_showBridgeDetailInfo(gate + "_A", 1); }
    else if ((bridge == "A4" || bridge == "AL3") && !clicked[gate + "_A_2"]) { clicked[gate + "_A_2"] = 'Y'; ap_showBridgeDetailInfo(gate + "_A", 2); }
    else if ((bridge == "B1" || bridge == "BL1") && !clicked[gate + "_B_0"]) { clicked[gate + "_B_0"] = 'Y'; ap_showBridgeDetailInfo(gate + "_B", 0); }
    else if ((bridge == "B2" || bridge == "BL1") && !clicked[gate + "_B_1"]) { clicked[gate + "_B_1"] = 'Y'; ap_showBridgeDetailInfo(gate + "_B", 1); }
    else if ((bridge == "B3" || bridge == "BL2") && !clicked[gate + "_B_1"]) { clicked[gate + "_B_1"] = 'Y'; ap_showBridgeDetailInfo(gate + "_B", 1); }
    else if ((bridge == "B4" || bridge == "BL3") && !clicked[gate + "_B_2"]) { clicked[gate + "_B_2"] = 'Y'; ap_showBridgeDetailInfo(gate + "_B", 2); }
    else if ((bridge == "C1" || bridge == "CL1") && !clicked[gate + "_C_0"]) { clicked[gate + "_C_0"] = 'Y'; ap_showBridgeDetailInfo(gate + "_C", 0); }
    else if ((bridge == "C2" || bridge == "CL1") && !clicked[gate + "_C_1"]) { clicked[gate + "_C_1"] = 'Y'; ap_showBridgeDetailInfo(gate + "_C", 1); }
    else if ((bridge == "C3" || bridge == "CL2") && !clicked[gate + "_C_1"]) { clicked[gate + "_C_1"] = 'Y'; ap_showBridgeDetailInfo(gate + "_C", 1); }
    else if ((bridge == "C4" || bridge == "CL3") && !clicked[gate + "_C_1"]) { clicked[gate + "_C_1"] = 'Y'; ap_showBridgeDetailInfo(gate + "_C", 2); }

   }

   planeModels.selectedModel = '';
   var i1 = bridge_code1.findIndex(x => x == labelInfo.gateClick);
   var i2 = bridge_code2.findIndex(x => x == labelInfo.gateClick);
   var i3 = bridge_code3.findIndex(x => x == labelInfo.gateClick);
   if (i1 > -1) {
    planeModels.selectedModel = bridge_planeModel1[i1];
    planeXYA.x = plane_currentXYA1[i1].x;
    planeXYA.y = plane_currentXYA1[i1].y;
    planeXYA.a = plane_currentXYA1[i1].a;
   }
   else if (i2 > -1) {
    planeModels.selectedModel = bridge_planeModel2[i2];
    planeXYA.x = plane_currentXYA2[i2].x;
    planeXYA.y = plane_currentXYA2[i2].y;
    planeXYA.a = plane_currentXYA2[i2].a;
   }
   else if (i3 > -1) {
    planeModels.selectedModel = bridge_planeModel3[i3];
    planeXYA.x = plane_currentXYA3[i3].x;
    planeXYA.y = plane_currentXYA3[i3].y;
    planeXYA.a = plane_currentXYA3[i3].a;
   }
   gui.updateDisplay(); // 更新 GUI 显示
  }

  function onMouseMove(event) {
   clicked = {};
   labelInfo.bridgeClick = "None";
   labelInfo.gateClick = "None";
   if (loading) return;
   // 计算鼠标在场景中的位置 
   mouse.x = (event.clientX / container.offsetWidth) * 2 - 1;
   mouse.y = -(event.clientY / container.offsetHeight) * 2 + 1;

   // 更新raycaster的射线方向
   raycaster.setFromCamera(mouse, camera);

   // 计算物体和射线的交点
   const intersects = raycaster.intersectObjects(scene.children);

   var oldGateMouseover = labelInfo.gateMouseover;
   if (intersects.length > 0) {
    intersects.forEach(element => {
     if (element.object.label) labelInfo.gateMouseover = element.object.label;
     if (element.object.obj_type) {
      if (element.object.obj_type == "A1" || element.object.obj_type == "A2" || element.object.obj_type == "A3" || element.object.obj_type == "A4")
       labelInfo.bridgeMouseover = element.object.label + "_A";
      if (element.object.obj_type == "B1" || element.object.obj_type == "B2" || element.object.obj_type == "B3" || element.object.obj_type == "B4")
       labelInfo.bridgeMouseover = element.object.label + "_B";
      if (element.object.obj_type == "C1" || element.object.obj_type == "C2" || element.object.obj_type == "C3" || element.object.obj_type == "C4")
       labelInfo.bridgeMouseover = element.object.label + "_C";
      if (element.object.obj_type == "label")
       labelInfo.gateMouseover = element.object.label;
     }
    });
    gui.updateDisplay(); // 更新 GUI 显示
    // axesHelper.position.copy(intersects[0].point);
   }
   var els = document.getElementsByClassName("plane");
   for (var i = 0; i < els.length; i++) {
    if (els[i].label == labelInfo.gateMouseover && els[i].innerHTML != "") {
     els[i].style.visibility = 'visible';
     setPlaneInfoTimeout(labelInfo.gateMouseover);
    }
   };
   oldGateMouseover = labelInfo.gateMouseover;
   brideMouseOVer(oldGateMouseover);
  }


  function backOrverAll() {
   gui_bridge.domElement.style.display = 'none';
   gui.domElement.style.display = 'block';
   bimModel.style.visibility = 'visible';
   bimModel_bridge.style.visibility = 'hidden';
   bimModel.style.display = 'block';
   bimModel_bridge.style.display = 'none';
   ap_didLeaveBridgeScene(enterBridgeId);
  }

  function loadAllModels() {
   const promises = [];



   loadModels(promises, bridge1, bridge_code1, bridgeData1, 20, 0, -20, 10);
   loadModels(promises, bridge2, bridge_code2, bridgeData2, -25, 0, -20, 10);
   loadModels(promises, bridge3, bridge_code3, bridgeData3, -15.5, 6, -23, 0);
   loadModels(promises, [[]], null, mainBuilding, 0, 0, 0, 0, 0.1, '#333333');


   loadPlaneModels(promises);


   Promise.all(promises).then(() => {
    clearAllplane();
    var els = document.getElementsByClassName("label plane");
    for (var i = 0; i < els.length; i++) {
     els[i].style.visibility = "hidden"
    };
    var elsf = document.getElementsByClassName("label fire");
    for (var i = 0; i < elsf.length; i++) {
     elsf[i].style.visibility = "hidden"
    };
    console.log("All models have been loaded:");
    loading = false;
    ap_didLaunchView();

   }).catch(error => {
    console.error("Error loading models:", error);
   });
  }

  function init() {
   // Scene setup
   scene = new THREE.Scene();
   // 添加天空背景
   scene.background = new THREE.Color('skyblue');
   // 添加地面
   var planeGeometry = new THREE.PlaneGeometry(1000, 1000); // 創建一個平面幾何體，寬和長均為10000
   var planeMaterial = new THREE.MeshLambertMaterial({ color: 0xc0f8b1 }); // 為平面創建材質，設定顏色為淺綠色

   var plane = new THREE.Mesh(planeGeometry, planeMaterial); // 使用幾何體和材質創建Mesh
   plane.rotation.x = -Math.PI / 2; // 將平面旋轉為水平，面向上方
   plane.position.y = -1; // 將地面位置稍微下降，避免與模型重疊
   scene.add(plane); // 將平面添加到場景中

   // 創建相機
   camera = new THREE.PerspectiveCamera(C.fov, container.offsetWidth / container.offsetHeight, C.near, C.far); // 使用配置參數創建透視相機
   camera.position.set(C.position.x, C.position.y, C.position.z); // 設定相機位置
   camera.rotation.set(C.rotation._x, C.rotation._y, C.rotation._z); // 設定相機旋轉
   camera.quaternion.set(C.quaternion._x, C.quaternion._y, C.quaternion._z, C.quaternion._w); // 設定相機四元數，用於控制旋轉
   camera.zoom = C.zoom; // 設定相機的縮放級別
   camera.updateProjectionMatrix(); // 更新相機的投影矩陣

   // 初始化渲染器
   renderer = new THREE.WebGLRenderer(); // 創建WebGL渲染器
   renderer.setSize(container.offsetWidth, container.offsetHeight);
   container.appendChild(renderer.domElement); // 將渲染器的DOM元素掛載到HTML中的指定元素上

   labelRenderer = new CSS2DRenderer();
   labelRenderer.setSize(container.offsetWidth, container.offsetHeight);
   labelRenderer.domElement.style.position = "absolute";
   labelRenderer.domElement.style.top = "0px";
   container.appendChild(labelRenderer.domElement);
   // 添加照明
   light = new THREE.DirectionalLight(0x888888, 1); // 創建一個白色的方向光源
   light.position.set(1, 100, 1).normalize(); // 設定光源的位置並正規化
   scene.add(light); // 將光源添加到場景中

   // 添加环境光 
   var ambientLight = new THREE.AmbientLight(0x222222);
   scene.add(ambientLight);

   axesHelper = new THREE.AxesHelper(5);
   //scene.add(axesHelper);


   // 實例化OrbitControls，允許用戶通過拖動來旋轉視角，滾動來縮放
   controls = new OrbitControls(camera, labelRenderer.domElement);
   controls.enableDamping = true; // 啟用阻尼效果，使交互更加平滑
   controls.dampingFactor = 0.25; // 設定阻尼系數
   controls.screenSpacePanning = false; // 禁用屏幕空間平移
   controls.target.set(C.target.x, C.target.y, C.target.z); // 設定控制的目標點
   controls.update(); // 更新控制器的內部狀態

   // 设置最小极角为0，防止低于地平面
   // Math.PI / 2 是90度，意味着视线平行于地面，不允许更低
   controls.minPolarAngle = 0; // 不允许移动到地面以下
   controls.maxPolarAngle = Math.PI / 2; // 最大旋转角度
   for (var c = 0; c < 8; c++)
    bridge1.push([]);
   for (var c = 0; c < 8; c++)
    bridge2.push([]);
   for (var c = 0; c < 5; c++)
    bridge3.push([]);
   // Handle STL upload 

   // 呼叫 loadModels 函數來加載和顯示所有模型
   loadAllModels();


   let sumX = 0, sumY = 0, sumZ = 0;
   let count = 0;

   // 计算所有对象的坐标平均值
   scene.traverse(function (object) {
    if (object.isMesh) {
     sumX += object.position.x;
     sumY += object.position.y;
     sumZ += object.position.z;
     count++;
    }
   });

   const centerX = sumX / count;
   const centerY = sumY / count;
   const centerZ = sumZ / count;

   // 设置摄像机看向新的中心点
   camera.lookAt(centerX, centerY, centerZ);
   camera.updateProjectionMatrix();

   // Raycaster和鼠标位置
   raycaster = new THREE.Raycaster();
   mouse = new THREE.Vector2();

   // 滑鼠事件
   container.addEventListener('mousedown', onMouseDown, false);
   container.addEventListener('click', onMouseClick, false);
   container.addEventListener('dblclick', onMouseDblClick, false);
   container.addEventListener('mousemove', onMouseMove, false);

   var cameraFolder = gui.addFolder('Camera');
   var camPosition = cameraFolder.addFolder('Position');
   var camRotation = cameraFolder.addFolder('Rotation');

   // 添加位置和旋转的控制
   camPosX = camPosition.add(camera.position, 'x', -500, 500);
   camPosY = camPosition.add(camera.position, 'y', -500, 500);
   camPosZ = camPosition.add(camera.position, 'z', -500, 500);

   camRotX = camRotation.add(camera.rotation, 'x', -Math.PI, Math.PI);
   camRotY = camRotation.add(camera.rotation, 'y', -Math.PI, Math.PI);
   camRotZ = camRotation.add(camera.rotation, 'z', -Math.PI, Math.PI);


   // 添加OrbitControls的目标点控制
   var controlsFolder = gui.addFolder('OrbitControls Target');
   controlTargetX = controlsFolder.add(controls.target, 'x', -1000, 1000);
   controlTargetY = controlsFolder.add(controls.target, 'y', -1000, 1000);
   controlTargetZ = controlsFolder.add(controls.target, 'z', -1000, 1000);
   cameraFolder.add({ setBridgeCamera }, 'setBridgeCamera').name('setBridgeCamera');
   cameraFolder.add({ resetCameraAndControls }, 'resetCameraAndControls').name('Reset Camera');
   var camMouse = gui.addFolder('Mouse');
   camMouse.add(labelInfo, 'gateClick').name('gateClick');
   camMouse.add(labelInfo, 'gateDblClick').name('gateDblClick');
   camMouse.add(labelInfo, 'gateMouseover').name('gateMouseover');
   camMouse.add(labelInfo, 'bridgeClick').name('bridgeClick');
   camMouse.add(labelInfo, 'bridgeDblClick').name('bridgeDblClick');
   camMouse.add(labelInfo, 'bridgeMouseover').name('bridgeMouseover');
   camMouse.add(labelInfo, 'modelClick').name('modelClick');
   var camPlane = gui.addFolder('Plane');
   var modelController = camPlane.add(planeModels, 'selectedModel', allModels).name('Aircraft Models');
   modelController.onChange(function (value) {
    setPlane();
   });
   camPlane.add(planeModels, 'removePlaneAction').name('leave');

   camPlane.add(planeXYA, 'x', -50, 50).name('planeX').onChange(function () {
    setPlaneXYA();

   });
   camPlane.add(planeXYA, 'y', -100, 100).name('planeY').onChange(function () {
    setPlaneXYA();

   });
   camPlane.add(planeXYA, 'a', 0, 360).name('planeA').onChange(function () {
    setPlaneXYA();

   });
   camPlane.add({ clearAllplane }, 'clearAllplane').name('Clear All Plane');


   var bridgeAngle = gui.addFolder('bridgeAngle');
   bridgeAngle.add(bridgeAngles, 'rotationA2', -360, 360).name('A2').onChange(function (angle) {
    setBridgeAngle('A');

   });
   bridgeAngle.add(bridgeAngles, 'rotationA3', -90, 90).name('A3').onChange(function (angle) {
    setBridgeAngle('A');

   });
   bridgeAngle.add(bridgeAngles, 'rotationAS2', 0, 3).name('AS2').onChange(function (angle) {
    setBridgeAngle('A');

   });
   bridgeAngle.add(bridgeAngles, 'rotationAS3', 0.3, 1).name('AS3').onChange(function (angle) {
    setBridgeAngle('A');

   });
   bridgeAngle.add(bridgeAngles, 'rotationB2', -360, 360).name('B2').onChange(function (angle) {
    setBridgeAngle('B');

   });
   bridgeAngle.add(bridgeAngles, 'rotationB3', -90, 90).name('B3').onChange(function (angle) {
    setBridgeAngle('B');

   });
   bridgeAngle.add(bridgeAngles, 'rotationBS2', 0, 3).name('BS2').onChange(function (angle) {
    setBridgeAngle('B');

   });
   bridgeAngle.add(bridgeAngles, 'rotationBS3', 0.3, 1).name('BS3').onChange(function (angle) {
    setBridgeAngle('B');

   });

   bridgeAngle.add(bridgeAngles, 'rotationC2', -360, 360).name('C2').onChange(function (angle) {
    setBridgeAngle('C');

   });
   bridgeAngle.add(bridgeAngles, 'rotationC3', -90, 90).name('C3').onChange(function (angle) {
    setBridgeAngle('C');

   });
   bridgeAngle.add(bridgeAngles, 'rotationCS2', 0, 3).name('CS2').onChange(function (angle) {
    setBridgeAngle('C');

   });
   bridgeAngle.add(bridgeAngles, 'rotationCS3', 0.3, 1).name('CS3').onChange(function (angle) {
    setBridgeAngle('C');

   });

   bridgeAngle.add(bridgeAngles, 'moveBridgeAction').name('move');

   bridgeAngle.add(bridgeAngles, 'removeBridgeAction').name('remove');
   var bridge_data_folder = gui.addFolder('bridge_data');
   bridge_data_folder.add({ value: '' }, 'value').name('wind data').onChange(function (value) {
    setWindData(labelInfo.gateClick, value)
   });

   bridge_data_folder.add({ value: '' }, 'value').name('plane data').onChange(function (value) {
    setPlaneData(labelInfo.gateClick, value)
   });
   bridge_data_folder.add({ value: '' }, 'value').name('label color').onChange(function (value) {
    setLabelDataColor(labelInfo.gateClick, value)
   });
   bridge_data_folder.add({ value: '' }, 'value').name('wind color').onChange(function (value) {
    setWindDataColor(labelInfo.gateClick, value)
   });
   bridge_data_folder.add({ value: '' }, 'value').name('plane color').onChange(function (value) {
    setPlaneDataColor(labelInfo.gateClick, value)
   });


   // 监听控制器的改变事件
   controls.addEventListener('change', () => {

    camPosX.setValue(camera.position.x);
    camPosY.setValue(camera.position.y);
    camPosZ.setValue(camera.position.z);

    camRotX.setValue(camera.rotation.x);
    camRotY.setValue(camera.rotation.y);
    camRotZ.setValue(camera.rotation.z);

    controlTargetX.setValue(controls.target.x);
    controlTargetY.setValue(controls.target.y);
    controlTargetZ.setValue(controls.target.z);
   });



   document.getElementById('setOverallData').addEventListener('click', setOverallData);
   document.getElementById('setBridgeData').addEventListener('click', setBridgeData);

   animate();


   setInterval(() => {
    if (loading) return;

    for (var i = 0; i < 8; i++) {
     if (planeMove1[i].current >= 0 && planeMove1[i].points && planeMove1[i].current < planeMove1[i].points.length) {
      setPlaneXYA(bridge_code1[i], planeMove1[i].points[planeMove1[i].current]);
      planeMove1[i].current++;
      if (planeMove1[i].current == planeMove1[i].points.length && planeMove1[i].type == 'leave') clearPlane(bridge_code1[i]);
     }
     if (bridgeMove1A[i].current >= 0 && bridgeMove1A[i].points && bridgeMove1A[i].current < bridgeMove1A[i].points.length) {
      runBridgeA(bridge_code1[i], bridgeMove1A[i].points[bridgeMove1A[i].current], i, null, null);
      bridgeMove1A[i].current++;
     }
     if (bridgeMove1B[i].current >= 0 && bridgeMove1B[i].points && bridgeMove1B[i].current < bridgeMove1B[i].points.length) {
      runBridgeB(bridge_code1[i], bridgeMove1B[i].points[bridgeMove1B[i].current], i, null, null);
      bridgeMove1B[i].current++;
     }
     if (bridgeMove1C[i].current >= 0 && bridgeMove1C[i].points && bridgeMove1C[i].current < bridgeMove1C[i].points.length) {
      runBridgeC(bridge_code1[i], bridgeMove1C[i].points[bridgeMove1C[i].current], i, null, null);
      bridgeMove1C[i].current++;
     }
     if (plain_info1[i] > 0) {
      plain_info1[i]--;
      if (plain_info1[i] == 0) document.getElementById(bridge_code1[i] + "_plane").style.visibility = "hidden";
     }
    }

    for (var i = 0; i < 8; i++) {
     if (planeMove2[i].current >= 0 && planeMove2[i].points && planeMove2[i].current < planeMove2[i].points.length) {
      setPlaneXYA(bridge_code2[i], planeMove2[i].points[planeMove2[i].current]);
      planeMove2[i].current++;
      if (planeMove2[i].current == planeMove2[i].points.length && planeMove2[i].type == 'leave') clearPlane(bridge_code2[i]);
     }
     if (bridgeMove2A[i].current >= 0 && bridgeMove2A[i].points && bridgeMove2A[i].current < bridgeMove2A[i].points.length) {
      runBridgeA(bridge_code2[i], bridgeMove2A[i].points[bridgeMove2A[i].current], null, i, null);
      bridgeMove2A[i].current++;
     }
     if (bridgeMove2B[i].current >= 0 && bridgeMove2B[i].points && bridgeMove2B[i].current < bridgeMove2B[i].points.length) {
      runBridgeB(bridge_code2[i], bridgeMove2B[i].points[bridgeMove2B[i].current], null, i, null);
      bridgeMove2B[i].current++;
     }
     if (bridgeMove2C[i].current >= 0 && bridgeMove2C[i].points && bridgeMove2C[i].current < bridgeMove2C[i].points.length) {
      runBridgeC(bridge_code2[i], bridgeMove2C[i].points[bridgeMove2C[i].current], null, i, null);
      bridgeMove2C[i].current++;
     }
     if (plain_info2[i] > 0) {
      plain_info2[i]--;
      if (plain_info2[i] == 0) document.getElementById(bridge_code2[i] + "_plane").style.visibility = "hidden";
     }
    }
    for (var i = 0; i < 5; i++) {
     if (planeMove3[i].current >= 0 && planeMove3[i].points && planeMove3[i].current < planeMove3[i].points.length) {
      setPlaneXYA(bridge_code3[i], planeMove3[i].points[planeMove3[i].current])
      planeMove3[i].current++;
      if (planeMove3[i].current == planeMove3[i].points.length && planeMove3[i].type == 'leave') clearPlane(bridge_code3[i]);
     }
     if (bridgeMove3A[i].current >= 0 && bridgeMove3A[i].points && bridgeMove3A[i].current < bridgeMove3A[i].points.length) {
      runBridgeA(bridge_code3[i], bridgeMove3A[i].points[bridgeMove3A[i].current], null, null, i);
      bridgeMove3A[i].current++;
     }
     if (plain_info3[i] > 0) {
      plain_info3[i]--;
      if (plain_info3[i] == 0) document.getElementById(bridge_code3[i] + "_plane").style.visibility = "hidden";
     }
    }

   }, 100);

  }
  function clearFlash_bridge(c) {
   if (_collect_intervalId_bridge[c]) {
    clearInterval(_collect_intervalId_bridge[c]);
    _collect_intervalId_bridge[c] = false;
    var i = _objCollect_bridge.findIndex(x => x.obj_type == c);
    _objCollect_bridge[i].material.opacity = 1; // 切换透明度
    _objCollect_bridge[i].material.transparent = false;
   }
  }

  function setFlash_bridge(c) {
   clearFlash_bridge(c);
   _collect_intervalId_bridge[c] = setInterval(function (c) {
    var i = _objCollect_bridge.findIndex(x => x.obj_type == c);
    _objCollect_bridge[i].material.transparent = true;
    _objCollect_bridge[i].material.opacity = (_objCollect_bridge[i].material.opacity === 1) ? 0 : 1; // 切换透明度
   }, 500, c); // 设置闪烁间隔（毫秒）
  }


  function createLights(mesh, box) {
   const lightMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // 黃色燈管
   const lightGeometry = new THREE.CylinderGeometry(0.02, 0.02, box.max.x - box.min.x, 32);

   // 在模型的上表面添加兩排燈管
   const light1 = new THREE.Mesh(lightGeometry, lightMaterial);
   light1.position.set(0, box.max.y + 0.02, (box.max.z + box.min.z) / 4);
   light1.rotation.z = Math.PI / 2;
   mesh.add(light1);

   const light2 = new THREE.Mesh(lightGeometry, lightMaterial);
   light2.position.set(0, box.max.y + 0.02, (box.max.z + box.min.z) * 3 / 4);
   light2.rotation.z = Math.PI / 2;
   mesh.add(light2);
  }

  function createWindows(mesh, box) {
   const windowMaterial = new THREE.MeshBasicMaterial({
    color: 0x87CEEB,
    transparent: true,
    opacity: 0.5
   });

   const windowGeometry = new THREE.PlaneGeometry(box.max.x - box.min.x, box.max.y - box.min.y);

   // 在模型的前後表面添加窗戶
   const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
   window1.position.set(0, 0, box.max.z + 0.02);
   mesh.add(window1);

   const window2 = new THREE.Mesh(windowGeometry, windowMaterial);
   window2.position.set(0, 0, box.min.z - 0.02);
   mesh.add(window2);

   // 創建窗框和X型支架
   createWindowFrame(mesh, box);
  }

  function createWindowFrame(mesh, box) {
   const frameMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });

   // 創建窗框
   const frameGeometry = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(box.min.x, box.min.y, box.max.z + 0.02),
    new THREE.Vector3(box.max.x, box.min.y, box.max.z + 0.02),
    new THREE.Vector3(box.max.x, box.max.y, box.max.z + 0.02),
    new THREE.Vector3(box.min.x, box.max.y, box.max.z + 0.02),
    new THREE.Vector3(box.min.x, box.min.y, box.max.z + 0.02)
   ]);
   const frame = new THREE.Line(frameGeometry, frameMaterial);
   mesh.add(frame);

   // 創建 X 型支架
   const supportGeometry = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(box.min.x, box.min.y, box.max.z + 0.02),
    new THREE.Vector3(box.max.x, box.max.y, box.max.z + 0.02),
    new THREE.Vector3(box.min.x, box.max.y, box.max.z + 0.02),
    new THREE.Vector3(box.max.x, box.min.y, box.max.z + 0.02)
   ]);
   const support = new THREE.LineSegments(supportGeometry, frameMaterial);
   mesh.add(support);
  }

  //載入模型
  function loadModels_bridge(tmpData) {
   tmpData.forEach((item, i) => {
    if (item.name.indexOf('.stl') > -1) {
     const loader = new STLLoader();
     loader.load(item.name, function (geometry) {
      var reflectivity = 0.1, emissive = '#333333', transparent = false, opacity = 1, color = item.color;

      var material = new THREE.MeshToonMaterial({ color: color, reflectivity: reflectivity, emissive: emissive, transparent: transparent, opacity: opacity });

      if (item.obj_type == 'a380') material = new THREE.MeshPhongMaterial({ color: 0xaaaaaa });

      if (item.obj_type == 'door') material = new THREE.MeshPhongMaterial({ color: 0x808080 });
      var stlModel = new THREE.Mesh(geometry, material);


      stlModel.obj_name = item.name;
      if (item.obj_type != '') stlModel.obj_type = item.obj_type;
      scene_bridge.add(stlModel);

      // 設置模型位置、縮放和旋轉

      stlModel.rotation.set(
       item.rotation._x,
       item.rotation._y,
       item.rotation._z
      );
      // 在这个闭包内，i和item是被正确捕获的
      stlModel.position.set(item.position.x, item.position.y, item.position.z);


      stlModel.scale.set(item.scale.x, item.scale.y, item.scale.z);

      _objCollect_bridge.push(stlModel);
     });
    }
    else if (item.name.indexOf('sphere') > -1) {
     const sphereSize = 0.1;
     const bulbGeometry = new THREE.SphereGeometry(sphereSize, 16, 8);
     const bulbMaterial = new THREE.MeshBasicMaterial({ color: item.color }); // 與光源顏色相同
     const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
     bulb.position.set(item.position.x, item.position.y, item.position.z);  // 設置與光源相同的位置
     bulb.obj_name = item.name;
     if (item.obj_type != '') bulb.obj_type = item.obj_type;
     scene_bridge.add(bulb);
     _objCollect_bridge.push(bulb);

     const _Div = document.createElement("div");
     _Div.style.padding = '2px';
     _Div.style.color = '#fff';
     _Div.style.fontSize = '10px';
     _Div.style.position = 'absolute';
     _Div.style.backgroundColor = 'rgba(25,25,25,0.5)';
     _Div.style.borderRadius = '5px';
     _Div.className = "label";
     _Div.textContent = item.obj_type;
     _Div.style.marginTop = '2px';
     if (item.obj_type != '') _Div.obj_type = item.obj_type;

     _Div.addEventListener('mouseover', function () {
      console.log('mouseover', item.obj_type);

     });
     _Div.addEventListener('mouseout', function () {
      console.log('mouseout', item.obj_type);
     });
     _Div.style.pointerEvents = 'auto';
     _Div.addEventListener('click', function () {
      console.log('click', item.obj_type);
     });
     const _Label = new CSS2DObject(_Div);
     _Label.position.set(0, 1, 0);
     bulb.add(_Label);

    }

   });

  }


  function onMouseDown_bridge(event) {
   if (loading) return;
   // 计算鼠标在场景中的位置 
   mouse_bridge.x = (event.clientX / container_bridge.offsetWidth) * 2 - 1;
   mouse_bridge.y = -(event.clientY / container_bridge.offsetHeight) * 2 + 1;

   // 更新raycaster的射线方向
   raycaster_bridge.setFromCamera(mouse_bridge, camera_bridge);

   // 计算物体和射线的交点
   const intersects = raycaster_bridge.intersectObjects(scene_bridge.children);

   if (intersects.length > 0) {
    // 如果有物体被选中 

    intersects.forEach(element => {
     console.log(element.object.obj_type);
    });
   }
  }

  function onMouseDblClick_bridge(event) {
   if (loading) return;
   // 计算鼠标在场景中的位置 
   mouse_bridge.x = (event.clientX / container_bridge.offsetWidth) * 2 - 1;
   mouse_bridge.y = -(event.clientY / container_bridge.offsetHeight) * 2 + 1;

   // 更新raycaster的射线方向
   raycaster_bridge.setFromCamera(mouse_bridge, camera_bridge);

   // 计算物体和射线的交点
   const intersects = raycaster_bridge.intersectObjects(scene_bridge.children);

   if (intersects.length > 0) {
    intersects.forEach(element => {
     console.log(element.object.obj_type);
    });

   }
  }

  function onMouseClick_bridge(event) {
   if (loading) return;
   // 如果是2d


   var mouseX = event.clientX;
   var mouseY = event.clientY;
   var _2dObjs = document.getElementById("bimModel_bridge").getElementsByClassName('label'); // 假设你的 CSS2DObject 的 div 有 'label' 这个类
   Array.from(_2dObjs).forEach(_2dObj => {
    var rect = _2dObj.getBoundingClientRect(); // 获取元素的屏幕坐标边界

    if (mouseX >= rect.left && mouseX <= rect.right && mouseY >= rect.top && mouseY <= rect.bottom) {
     if (/^[A-Z]$/.test(_2dObj.obj_type)) ap_showBridgePositionInfo(enterBridgeId, _2dObj.obj_type);
     // 在这里执行你的逻辑
    }
   });

   // 计算鼠标在场景中的位置 
   mouse_bridge.x = (event.clientX / container_bridge.offsetWidth) * 2 - 1;
   mouse_bridge.y = -(event.clientY / container_bridge.offsetHeight) * 2 + 1;

   // 更新raycaster的射线方向
   raycaster_bridge.setFromCamera(mouse_bridge, camera_bridge);

   // 计算物体和射线的交点
   const intersects = raycaster_bridge.intersectObjects(scene_bridge.children);

   if (intersects.length > 0) {
    // 如果有物体被选中 
    intersects.forEach(element => {
     if (/^[A-Z]$/.test(element.object.obj_type)) ap_showBridgePositionInfo(enterBridgeId, element.object.obj_type);
    });
   }
  }

  function onMouseMove_bridge(event) {
   if (loading) return;
   // 计算鼠标在场景中的位置 
   mouse_bridge.x = (event.clientX / container_bridge.offsetWidth) * 2 - 1;
   mouse_bridge.y = -(event.clientY / container_bridge.offsetHeight) * 2 + 1;

   // 更新raycaster的射线方向
   raycaster_bridge.setFromCamera(mouse_bridge, camera_bridge);

   // 计算物体和射线的交点
   const intersects = raycaster_bridge.intersectObjects(scene_bridge.children);

   if (intersects.length > 0) {
    intersects.forEach(element => {
    });
   }
  }



  function init_bridge() {
   // Scene setup
   scene_bridge = new THREE.Scene();
   // 添加天空背景
   scene_bridge.background = new THREE.Color('skyblue');
   // 添加地面
   var planeGeometry = new THREE.PlaneGeometry(10000, 10000); // 創建一個平面幾何體，寬和長均為10000
   var planeMaterial = new THREE.MeshLambertMaterial({ color: 0xc0f8b1 }); // 為平面創建材質，設定顏色為淺綠色
   var plane_bridge = new THREE.Mesh(planeGeometry, planeMaterial); // 使用幾何體和材質創建Mesh
   plane_bridge.rotation.x = -Math.PI / 2; // 將平面旋轉為水平，面向上方
   plane_bridge.position.y = -1; // 將地面位置稍微下降，避免與模型重疊
   scene_bridge.add(plane_bridge); // 將平面添加到場景中

   // 創建相機
   camera_bridge = new THREE.PerspectiveCamera(C_bridgeC.fov, container_bridge.offsetWidth / container_bridge.offsetHeight, C_bridgeC.near, C_bridgeC.far); // 使用配置參數創建透視相機
   camera_bridge.position.set(C_bridgeC.position.x, C_bridgeC.position.y, C_bridgeC.position.z); // 設定相機位置
   camera_bridge.rotation.set(C_bridgeC.rotation._x, C_bridgeC.rotation._y, C_bridgeC.rotation._z); // 設定相機旋轉
   camera_bridge.quaternion.set(C_bridgeC.quaternion._x, C_bridgeC.quaternion._y, C_bridgeC.quaternion._z, C_bridgeC.quaternion._w); // 設定相機四元數，用於控制旋轉
   camera_bridge.zoom = C_bridgeC.zoom; // 設定相機的縮放級別
   camera_bridge.updateProjectionMatrix(); // 更新相機的投影矩陣

   // 初始化渲染器
   renderer_bridge = new THREE.WebGLRenderer(); // 創建WebGL渲染器
   renderer_bridge.setSize(container_bridge.offsetWidth, container_bridge.offsetHeight);
   container_bridge.appendChild(renderer_bridge.domElement); // 將渲染器的DOM元素掛載到HTML中的指定元素上

   labelRenderer_bridge = new CSS2DRenderer();
   labelRenderer_bridge.setSize(container_bridge.offsetWidth, container_bridge.offsetHeight);
   labelRenderer_bridge.domElement.style.position = "absolute";
   labelRenderer_bridge.domElement.style.top = "0px";
   container_bridge.appendChild(labelRenderer_bridge.domElement);
   // 添加照明
   light_bridge = new THREE.DirectionalLight(0xffffff, 1); // 創建一個白色的方向光源
   light_bridge.position.set(50, 50, 1).normalize(); // 設定光源的位置並正規化
   light_bridge.position.set(50, 50, 30);
   light_bridge.castShadow = true;
   light_bridge.shadow.mapSize.width = 2048;
   light_bridge.shadow.mapSize.height = 2048;
   light_bridge.shadow.camera.near = 1;
   light_bridge.shadow.camera.far = 200;
   light_bridge.shadow.camera.left = -50;
   light_bridge.shadow.camera.right = 50;
   light_bridge.shadow.camera.top = 50;
   light_bridge.shadow.camera.bottom = -50;
   scene_bridge.add(light_bridge); // 將光源添加到場景中

   // 實例化OrbitControls，允許用戶通過拖動來旋轉視角，滾動來縮放
   controls_bridge = new OrbitControls(camera_bridge, labelRenderer_bridge.domElement);
   controls_bridge.enableDamping = true; // 啟用阻尼效果，使交互更加平滑
   controls_bridge.dampingFactor = 0.25; // 設定阻尼系數
   controls_bridge.screenSpacePanning = false; // 禁用屏幕空間平移
   controls_bridge.target.set(C_bridgeC.target.x, C_bridgeC.target.y, C_bridgeC.target.z); // 設定控制的目標點
   controls_bridge.update(); // 更新控制器的內部狀態

   // 设置最小极角为0，防止低于地平面
   // Math.PI / 2 是90度，意味着视线平行于地面，不允许更低
   controls_bridge.minPolarAngle = 0; // 不允许移动到地面以下
   controls_bridge.maxPolarAngle = Math.PI / 2; // 最大旋转角度
   // Handle STL upload 




   // 设置材质
   const grayMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
   const blueMaterial = new THREE.MeshPhongMaterial({ color: 0x2222ff, transparent: true, opacity: 0.7 });

   // 创建地面
   const groundGeometry = new THREE.PlaneGeometry(100, 100);
   const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x999999 });
   const ground = new THREE.Mesh(groundGeometry, groundMaterial);
   ground.rotation.x = -Math.PI / 2;
   ground.position.set(25, -0.1, 25);
   ground.receiveShadow = true;
   scene_bridge.add(ground);

   // 创建桥体结构（灰色长方体）
   const bridgeBody = new THREE.Mesh(new THREE.BoxGeometry(10, 3, 2), grayMaterial);
   bridgeBody.position.set(0, 1, 0);
   bridgeBody.castShadow = true;
   bridgeBody.receiveShadow = true;

   // 创建移动系统（灰色圆柱体）
   const movingSystem = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 4, 32), grayMaterial);
   movingSystem.position.set(5, 4, 0);
   movingSystem.castShadow = true;
   movingSystem.receiveShadow = true;

   // 创建旋转组，以便桥体结构能够水平旋转
   const rotatingGroup = new THREE.Group();
   rotatingGroup.position.set(5, 4, 0); // 设置旋转组的位置为移动系统的位置
   rotatingGroup.add(bridgeBody); // 将桥体结构添加到旋转组

   const centralSupportPillar = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 8, 32), grayMaterial);
   centralSupportPillar.position.set(5, 0, 0); // 位置与移动系统相同，但 y 坐标为 0
   centralSupportPillar.castShadow = true;
   centralSupportPillar.receiveShadow = true;
   scene_bridge.add(centralSupportPillar);

   // 调整桥体结构位置以保持连接点
   bridgeBody.position.set(5, 0, 0);

   // 创建新支撑柱
   const createSupportPillar = (x, z) => {
    const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 5, 32), grayMaterial);
    pillar.position.set(x, -2.5, z);
    pillar.castShadow = true;
    pillar.receiveShadow = true;
    rotatingGroup.add(pillar); // 将支撑柱添加到旋转组
   };

   createSupportPillar(7.5, 1);
   createSupportPillar(7.5, -1);

   // 将旋转组添加到场景中
   scene_bridge.add(rotatingGroup);

   // 将移动系统添加到场景中
   scene_bridge.add(movingSystem);

   // 创建乘客通道
   const passengerTunnel = new THREE.Group();

   const topTunnel = new THREE.Mesh(new THREE.BoxGeometry(15, 0.5, 3), grayMaterial);
   topTunnel.position.y = 2.25;
   topTunnel.castShadow = true;
   topTunnel.receiveShadow = true;
   passengerTunnel.add(topTunnel);
   const topTunnel1 = new THREE.Mesh(new THREE.BoxGeometry(5, 0.6, 3), grayMaterial);
   topTunnel1.position.y = 2.35;
   topTunnel1.position.x = -0;
   topTunnel1.castShadow = true;
   topTunnel1.receiveShadow = true;
   passengerTunnel.add(topTunnel1);
   const topTunnel2 = new THREE.Mesh(new THREE.BoxGeometry(5, 0.7, 3), grayMaterial);
   topTunnel2.position.y = 2.45;
   topTunnel2.position.x = -5;
   topTunnel2.castShadow = true;
   topTunnel2.receiveShadow = true;
   passengerTunnel.add(topTunnel2);

   const sideTunnel1 = new THREE.Mesh(new THREE.BoxGeometry(15, 2, 0.1), blueMaterial);
   sideTunnel1.position.set(0, 1, 1.5);
   sideTunnel1.castShadow = true;
   passengerTunnel.add(sideTunnel1);

   const sideTunnel2 = sideTunnel1.clone();
   sideTunnel2.position.z = -1.5;
   passengerTunnel.add(sideTunnel2);

   const bottomTunnel = new THREE.Mesh(new THREE.BoxGeometry(15, 0.5, 3), grayMaterial);
   bottomTunnel.position.y = -0.25;
   bottomTunnel.castShadow = true;
   bottomTunnel.receiveShadow = true;
   passengerTunnel.add(bottomTunnel);
   const bottomTunnel1 = new THREE.Mesh(new THREE.BoxGeometry(7, 1, 2), grayMaterial);
   bottomTunnel1.position.y = -1;
   bottomTunnel1.position.x = -2;
   bottomTunnel1.castShadow = true;
   bottomTunnel1.receiveShadow = true;
   passengerTunnel.add(bottomTunnel1);
   const bottomTunnel2 = new THREE.Mesh(new THREE.BoxGeometry(3, 1, 2), grayMaterial);
   bottomTunnel2.position.y = -1;
   bottomTunnel2.position.x = 5;
   bottomTunnel2.castShadow = true;
   bottomTunnel2.receiveShadow = true;
   passengerTunnel.add(bottomTunnel2);


   const boorTunnel1 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 3, 1), grayMaterial);
   boorTunnel1.position.y = 1;
   boorTunnel1.position.x = 7.5;
   boorTunnel1.position.z = -1.3;
   boorTunnel1.castShadow = true;
   boorTunnel1.receiveShadow = true;
   passengerTunnel.add(boorTunnel1);



   const boorTunnel2 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 3, 1), grayMaterial);
   boorTunnel2.position.y = 1;
   boorTunnel2.position.x = 7.5;
   boorTunnel2.position.z = 1.3;
   boorTunnel2.castShadow = true;
   boorTunnel2.receiveShadow = true;
   passengerTunnel.add(boorTunnel2);



   const boorTunnel3 = new THREE.Mesh(new THREE.BoxGeometry(4.5, 0.2, 3), grayMaterial);
   boorTunnel3.position.y = -0.6;
   boorTunnel3.position.x = 8;
   boorTunnel3.position.z = 0;
   boorTunnel3.castShadow = true;
   boorTunnel3.receiveShadow = true;
   passengerTunnel.add(boorTunnel3);




   const boorTunnel4 = new THREE.Mesh(new THREE.BoxGeometry(4.5, 0.2, 3), grayMaterial);
   boorTunnel4.position.y = 2.4;
   boorTunnel4.position.x = 8;
   boorTunnel4.position.z = 0;
   boorTunnel4.castShadow = true;
   boorTunnel4.receiveShadow = true;
   passengerTunnel.add(boorTunnel4);



   const boorTunnel5 = new THREE.Mesh(new THREE.BoxGeometry(4.5, 3, 0.2), grayMaterial);
   boorTunnel5.position.y = 1;
   boorTunnel5.position.x = 8;
   boorTunnel5.position.z = 1.5;
   boorTunnel5.castShadow = true;
   boorTunnel5.receiveShadow = true;
   passengerTunnel.add(boorTunnel5);




   const boorTunnel6 = new THREE.Mesh(new THREE.BoxGeometry(4.5, 3, 0.2), grayMaterial);
   boorTunnel6.position.y = 1;
   boorTunnel6.position.x = 8;
   boorTunnel6.position.z = -1.5;
   boorTunnel6.castShadow = true;
   boorTunnel6.receiveShadow = true;
   passengerTunnel.add(boorTunnel6);



   passengerTunnel.position.set(12.5, 3, 0);
   scene_bridge.add(passengerTunnel);


   // 修改楼梯部分
   const stairs = new THREE.Group();
   const stairWidth = 1;
   const stairHeight = 0.066;
   const stairDepth = 0.5;
   const stairCount = 10;
   const stairRise = 0.3;
   const stairRun = 0.5;

   for (let i = 0; i < stairCount; i++) {
    const step = new THREE.Mesh(new THREE.BoxGeometry(stairWidth, stairHeight, stairDepth), grayMaterial);
    step.position.set(-2, i * stairRise, i * -stairRun);
    step.castShadow = true;
    step.receiveShadow = true;
    stairs.add(step);
   }

   // 创建楼梯扶手
   const createHandrail = (side) => {
    const handrailRadius = 0.05;
    const handrailHeight = stairCount * stairRise;
    const handrailLength = stairCount * stairRun;

    const handrailGeometry = new THREE.CylinderGeometry(
     handrailRadius,
     handrailRadius,
     Math.sqrt(handrailHeight * handrailHeight + handrailLength * handrailLength),
     32
    );
    const handrail = new THREE.Mesh(handrailGeometry, grayMaterial);

    // 设置扶手位置和旋转
    handrail.position.set(side * (stairWidth / 2 + handrailRadius) - 2, handrailHeight / 2 + 1, -handrailLength / 2);
    handrail.rotation.x = Math.atan2(handrailHeight, handrailLength) - Math.PI / 2;

    handrail.castShadow = true;
    handrail.receiveShadow = true;
    return handrail;
   };

   // 添加左右两侧的扶手
   stairs.add(createHandrail(-1)); // 左侧扶手
   stairs.add(createHandrail(1));  // 右侧扶手

   stairs.position.set(15, 0, 4);
   stairs.rotation.y = -Math.PI / 2;
   scene_bridge.add(stairs);


   // 创建楼梯连接部分（两侧的扁长方体）
   const createStairConnector = (side) => {
    const connectorWidth = 0.2; // 连接部分的宽度
    const connectorHeight = Math.sqrt(Math.pow(stairCount * stairRise, 2) + Math.pow(stairCount * stairRun, 2)); // 连接部分的长度
    const connectorDepth = stairDepth; // 连接部分的深度与楼梯深度相同

    const connectorGeometry = new THREE.BoxGeometry(connectorWidth, connectorHeight, connectorDepth);
    const connector = new THREE.Mesh(connectorGeometry, grayMaterial);

    // 设置连接部分的位置和旋转
    connector.position.set(
     side * (stairWidth / 2 + connectorWidth / 2) - 2,
     (stairCount * stairRise) / 2,
     -(stairCount * stairRun) / 2
    );
    connector.rotation.x = Math.atan2(stairCount * stairRise, stairCount * stairRun) - Math.PI / 2;

    connector.castShadow = true;
    connector.receiveShadow = true;
    return connector;
   };

   // 添加左右两侧的楼梯连接部分
   stairs.add(createStairConnector(-1)); // 左侧连接部分
   stairs.add(createStairConnector(1));  // 右侧连接部分


   // 创建楼梯支撑柱
   const createStairSupportPillar = (side, isTop) => {
    const pillarRadius = 0.05;
    const pillarHeight = isTop ? stairCount * stairRise : stairCount * stairRise + 2; // 上方支撑柱高度与楼梯齐平，下方支撑柱高度与扶手相同

    const pillarGeometry = new THREE.CylinderGeometry(pillarRadius, pillarRadius, pillarHeight, 32);
    const pillar = new THREE.Mesh(pillarGeometry, grayMaterial);

    // 设置支撑柱位置
    pillar.position.set(
     side * (stairWidth / 2 + pillarRadius) - 2,
     isTop ? pillarHeight / 50 : pillarHeight / 2 - 1, // 调整上方支撑柱的 y 坐标
     isTop ? 0 : -(stairCount * stairRun)
    );

    pillar.castShadow = true;
    pillar.receiveShadow = true;
    return pillar;
   };

   // 添加四个支撑柱
   stairs.add(createStairSupportPillar(-1, true));  // 左上
   stairs.add(createStairSupportPillar(1, true));   // 右上
   stairs.add(createStairSupportPillar(-1, false)); // 左下
   stairs.add(createStairSupportPillar(1, false));  // 右下

   // 保留原始支撑柱
   const createOriginalSupportPillar = (x, z) => {
    const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 3, 5), grayMaterial);
    pillar.position.set(x, 4, z);
    pillar.castShadow = true;
    pillar.receiveShadow = true;
    scene_bridge.add(pillar);
   };

   createOriginalSupportPillar(10, 1.4);
   createOriginalSupportPillar(10, -1.4);
   createOriginalSupportPillar(15, 1.4);
   createOriginalSupportPillar(15, -1.4);
   createOriginalSupportPillar(20, 1.4);
   createOriginalSupportPillar(20, -1.4);
   // 創建第一個垂直柱子
   const pillar1 = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 6.5, 3), grayMaterial);
   pillar1.position.set(19, 3.5, 1.3);
   pillar1.castShadow = true;
   pillar1.receiveShadow = true;
   scene_bridge.add(pillar1);

   // 創建第二個垂直柱子
   const pillar2 = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 6.5, 3), grayMaterial);
   pillar2.position.set(19, 3.5, -1.3);
   pillar2.castShadow = true;
   pillar2.receiveShadow = true;
   scene_bridge.add(pillar2);

   // 創建水平柱子
   const horizontalPillar = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 2.6), grayMaterial);
   horizontalPillar.position.set(19, 0.5, 0); // 設置水平柱子的中心位置在兩個垂直柱子的底部之間
   horizontalPillar.castShadow = true;
   horizontalPillar.receiveShadow = true;
   scene_bridge.add(horizontalPillar);

   // 創建第一個輪子
   const wheel1 = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.2, 12), grayMaterial);
   wheel1.position.set(19, 0.3, 1.3); // 設置輪子的位置
   wheel1.rotation.x = Math.PI / 2; // 旋轉輪子使其變成扁的
   wheel1.castShadow = true;
   wheel1.receiveShadow = true;
   scene_bridge.add(wheel1);

   // 創建第二個輪子
   const wheel2 = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.2, 12), grayMaterial);
   wheel2.position.set(19, 0.3, -1.3); // 設置輪子的位置
   wheel2.rotation.x = Math.PI / 2; // 旋轉輪子使其變成扁的
   wheel2.castShadow = true;
   wheel2.receiveShadow = true;
   scene_bridge.add(wheel2);

   // 水平旋转桥体结构 -45 度
   rotatingGroup.rotation.y = Math.PI / 2 + Math.PI / 4;




   // 呼叫 loadModels 函數來加載和顯示所有模型
   loadModels_bridge(bridgeData);

   document.getElementById('backButton').addEventListener('click', backOrverAll);
   document.getElementById('viewAButton').addEventListener('click', function () {

    camera_bridge.position.set(C_bridgeA.position.x, C_bridgeA.position.y, C_bridgeA.position.z); // 設定相機位置
    camera_bridge.rotation.set(C_bridgeA.rotation._x, C_bridgeA.rotation._y, C_bridgeA.rotation._z); // 設定相機旋轉
    camera_bridge.quaternion.set(C_bridgeA.quaternion._x, C_bridgeA.quaternion._y, C_bridgeA.quaternion._z, C_bridgeA.quaternion._w); // 設定相機四元數，用於控制旋轉
    camera_bridge.zoom = C_bridgeA.zoom; // 設定相機的縮放級別
    camera_bridge.updateProjectionMatrix(); // 更新相機的投影矩陣

    controls_bridge.target.set(C_bridgeA.target.x, C_bridgeA.target.y, C_bridgeA.target.z); // 設定控制的目標點
    controls_bridge.update(); // 更新控制器的內部狀態

   });
   document.getElementById('viewBButton').addEventListener('click', function () {
    if (loading) return;


    camera_bridge.position.set(C_bridgeB.position.x, C_bridgeB.position.y, C_bridgeB.position.z); // 設定相機位置
    camera_bridge.rotation.set(C_bridgeB.rotation._x, C_bridgeB.rotation._y, C_bridgeB.rotation._z); // 設定相機旋轉
    camera_bridge.quaternion.set(C_bridgeB.quaternion._x, C_bridgeB.quaternion._y, C_bridgeB.quaternion._z, C_bridgeB.quaternion._w); // 設定相機四元數，用於控制旋轉
    camera_bridge.zoom = C_bridgeB.zoom; // 設定相機的縮放級別
    camera_bridge.updateProjectionMatrix(); // 更新相機的投影矩陣

    controls_bridge.target.set(C_bridgeB.target.x, C_bridgeB.target.y, C_bridgeB.target.z); // 設定控制的目標點
    controls_bridge.update(); // 更新控制器的內部狀態

   });
   document.getElementById('viewCButton').addEventListener('click', function () {


    camera_bridge.position.set(C_bridgeC.position.x, C_bridgeC.position.y, C_bridgeC.position.z); // 設定相機位置
    camera_bridge.rotation.set(C_bridgeC.rotation._x, C_bridgeC.rotation._y, C_bridgeC.rotation._z); // 設定相機旋轉
    camera_bridge.quaternion.set(C_bridgeC.quaternion._x, C_bridgeC.quaternion._y, C_bridgeC.quaternion._z, C_bridgeC.quaternion._w); // 設定相機四元數，用於控制旋轉
    camera_bridge.zoom = C_bridgeC.zoom; // 設定相機的縮放級別
    camera_bridge.updateProjectionMatrix(); // 更新相機的投影矩陣

    controls_bridge.target.set(C_bridgeC.target.x, C_bridgeC.target.y, C_bridgeC.target.z); // 設定控制的目標點
    controls_bridge.update(); // 更新控制器的內部狀態
   });
   raycaster_bridge = new THREE.Raycaster();
   mouse_bridge = new THREE.Vector2();
   // 滑鼠事件
   container_bridge.addEventListener('mousedown', onMouseDown_bridge, false);
   container_bridge.addEventListener('click', onMouseClick_bridge, false);
   container_bridge.addEventListener('dblclick', onMouseDblClick_bridge, false);
   container_bridge.addEventListener('mousemove', onMouseMove_bridge, false);

   let sumX = 0, sumY = 0, sumZ = 0;
   let count = 0;

   // 计算所有对象的坐标平均值
   scene_bridge.traverse(function (object) {
    if (object.isMesh) {
     sumX += object.position.x;
     sumY += object.position.y;
     sumZ += object.position.z;
     count++;
    }
   });

   const centerX = sumX / count;
   const centerY = sumY / count;
   const centerZ = sumZ / count;

   // 设置摄像机看向新的中心点
   camera_bridge.lookAt(centerX, centerY, centerZ);
   camera_bridge.updateProjectionMatrix();

   // 从 'A' 到 'T'
   var startChar = 'A'.charCodeAt(0);
   var endChar = 'T'.charCodeAt(0);

   for (let i = startChar; i <= endChar; i++) {
    let char = String.fromCharCode(i);
    // 创建颜色属性和初始值
    colors_bridge[char] = "#ffffff";

    // 添加颜色选择器到 GUI
    gui_bridge.addColor(colors_bridge, char).name(`Color ${char}`).onChange(function (value) {
     // 更新颜色
     var i = _objCollect_bridge.findIndex(x => x.obj_type == this.property);
     if (i > -1) _objCollect_bridge[i].material.color.set(evalue);
    });
   }
   gui_bridge.domElement.style.display = 'none';
   animate_bridge();
  }



  function animate() {
   requestAnimationFrame(animate);
   controls.update(); // 只有当 enableDamping 或 autoRotate 被设置时才需要
   renderer.render(scene, camera);
   labelRenderer.render(scene, camera);
  }


  function animate_bridge() {
   requestAnimationFrame(animate_bridge);
   controls_bridge.update(); // 只有当 enableDamping 或 autoRotate 被设置时才需要
   renderer_bridge.render(scene_bridge, camera_bridge);
   labelRenderer_bridge.render(scene_bridge, camera_bridge);
  }

  init();
  init_bridge();


  var event_count;


  function brideMouseOVer(a) {

   //document.getElementById("event").value += event_count + ':brideMouseOVer ' + a + '\n';
   event_count++;
  }

  function bim_launchView(elementId) {
   event_count = 1;
   document.getElementById("event").value = event_count + ':bim_launchView ' + elementId + '\n' + document.getElementById("event").value;
   event_count++;
  }

  function ap_didLaunchView() {

   document.getElementById("event").value = event_count + ':ap_didLaunchView\n' + document.getElementById("event").value;
   event_count++;
  }

  function setOverallData() {
   bim_setOverallData(JSON.parse(document.getElementById("json").value));
  }

  let lastStatus = {}

  function bim_setOverallData(overallData) {
   document.getElementById("event").value = event_count + ':overallData\n' + document.getElementById("event").value;
   event_count++;
   overallData.gates.forEach(element => {
    if (!lastStatus[element.id]) lastStatus[element.id] = JSON.parse(JSON.stringify(element));

    setPlaneData(element.id, element.flightLegInfo.flightNumber + ' ' + element.flightLegInfo.aircraftType + '<br/>' + element.flightLegInfo.aTime + '<br/>' + element.flightLegInfo.dTime)
    setLabelData(element.id, element.name); // gates.name：文字顯示在#G1
    //gates.statusColor：顏色顯示在#G1, #G3
    setLabelDataColor(element.id, element.statusColor);
    setWindDataColor(element.id, element.statusColor);
    setWindData(element.id, '');
    if (element.windSpeedAvg && element.windSpeedMax) setWindData(element.id, element.windSpeedAvg + '/' + element.windSpeedMax);


    // aTime 值由 null 轉為有值時，播放飛機進場動畫。 (aTime==null && new_aTime!=null)
    if (lastStatus[element.id].flightLegInfo.aTime == null && element.flightLegInfo.aTime != null) setPlane(element.id, element.flightLegInfo.aircraftType);
    //當aTime 由有值轉為 null 時，播放飛機離場動畫。(aTime!=null && new_aTime==null
    if (lastStatus[element.id].flightLegInfo.aTime != null && element.flightLegInfo.aTime == null) removePlane(element.id);


    //isHidden 是否隱藏。(true: 隱藏, false: 顯示)
    //isFlash 是否閃爍。(true: 閃爍, false: 不閃爍)
    //作用於#G1 是否閃爍
    if (element.isFlash)
     setLabelFlash(element.id);
    else
     clearLabelFlash(element.id);
    //作用於#G1 是否顯示
    setLabelVisible(element.id, element.isHidden);


    if (element.bridges.length == 1) {
     setBridgeVisible(element.id, 'B', true);
     setBridgeVisible(element.id, 'C', true);
     setLabelVisible(element.id + '_B', true);
     setLabelVisible(element.id + '_C', true);
    }

    if (element.bridges.length >= 1) {
     //2.控制空橋靠橋/撤僑動畫的狀態(status)，應該以Overall.gates.bridges.status為主，而非Overall.gates.status。
     //由不為 4(服務)轉為 4(服務)時，播放空橋靠橋動畫。 (status!=4 && new_status==4)
     if (lastStatus[element.id].bridges[0].status != 4 && element.bridges[0].status == 4) moveBridge(element.id, 'A');
     //當 status 值由 4(服務)轉為 2(閒置)或 5(撤橋)時，播放空橋撤橋動畫。(status==4 && (new_status==2 || new_status==5))
     if (lastStatus[element.id].bridges[0].status == 4 && (element.bridges[0].status == 2 || element.bridges[0].status == 5)) removeBridge(element.id, 'A');

    }
    if (element.bridges.length == 2) {
     setBridgeVisible(element.id, 'C', true);
     setLabelVisible(element.id, element.isHidden);
     setLabelVisible(element.id + '_C', true);

    }

    if (element.bridges.length >= 2) {
     //2.控制空橋靠橋/撤僑動畫的狀態(status)，應該以Overall.gates.bridges.status為主，而非Overall.gates.status。
     //由不為 4(服務)轉為 4(服務)時，播放空橋靠橋動畫。 (status!=4 && new_status==4)
     if (lastStatus[element.id].bridges[1].status != 4 && element.bridges[1].status == 4) moveBridge(element.id, 'B');
     //當 status 值由 4(服務)轉為 2(閒置)或 5(撤橋)時，播放空橋撤橋動畫。(status==4 && (new_status==2 || new_status==5))
     if (lastStatus[element.id].bridges[1].status == 4 && (element.bridges[1].status == 2 || element.bridges[1].status == 5)) removeBridge(element.id, 'B');

    }

    if (element.bridges.length == 3) {
     //2.控制空橋靠橋/撤僑動畫的狀態(status)，應該以Overall.gates.bridges.status為主，而非Overall.gates.status。
     //由不為 4(服務)轉為 4(服務)時，播放空橋靠橋動畫。 (status!=4 && new_status==4)
     if (lastStatus[element.id].bridges[2].status != 4 && element.bridges[2].status == 4) moveBridge(element.id, 'C');
     //當 status 值由 4(服務)轉為 2(閒置)或 5(撤橋)時，播放空橋撤橋動畫。(status==4 && (new_status==2 || new_status==5))
     if (lastStatus[element.id].bridges[2].status == 4 && (element.bridges[2].status == 2 || element.bridges[2].status == 5)) removeBridge(element.id, 'C');

    }

    element.bridges.forEach(b_element => {

     setLabelData(b_element.id, b_element.name); // gates.name：文字顯示在#B
     if (b_element.isFlash)
      setLabelFlash(b_element.id);
     else
      clearLabelFlash(b_element.id);
     setLabelVisible(b_element.id, b_element.isHidden);
     //setVisible(element.id, b_element.id, null, b_element.isHidden);
     setLabelDataColor(b_element.id, b_element.statusColor);
     setColor(element.id, b_element.id, null, b_element.statusColor);
     //：作用於#B2/ #B3/ #B4；若只有一個{}，僅會顯示#B2；如有 3 個{}，會顯示 #B2/ #B3/ #B4

     //C16_AL1_fire
     setLabelVisible(b_element.id + "L1_fire", !b_element.fireAlarm);

     b_element.details.forEach((bi_element, index) => {

      if (bi_element.isFlash)
       setFlash(element.id, b_element.id, index + 1);
      else
       clearFlash(element.id, b_element.id, index + 1);
      setVisible(element.id, b_element.id, index + 1, bi_element.isHidden); // 1~3
      setColor(element.id, b_element.id, index + 1, bi_element.statusColor); // 1~3
     });

    });

    lastStatus[element.id] = JSON.parse(JSON.stringify(element));
   });

  }

  function ap_showBridgeInfo(bridgeId) {
   document.getElementById("event").value = event_count + ':ap_showBridgeInfo ' + bridgeId + '\n' + document.getElementById("event").value;
   event_count++;

  }

  function ap_showBridgeDetailInfo(bridgeId, detailIndex) {
   document.getElementById("event").value = event_count + ':ap_showBridgeDetailInfo ' + bridgeId + ',' + detailIndex + '\n' + document.getElementById("event").value;
   event_count++;

  }

  let lastBridgeStatus = {}

  function ap_didEnterBridgeScene(bridgeId) {
   enterBridgeId = bridgeId;
   document.getElementById("event").value = event_count + ':ap_didEnterBridgeScene ' + bridgeId + '\n' + document.getElementById("event").value;
   event_count++;
   document.getElementById("bridge_label").innerText = bridgeId + " 空橋狀況";
   if (!(bridgeId in lastBridgeStatus)) {
    lastBridgeStatus[bridgeId] = {
     "bridgeId": "E01_A",
     "status": [
      { "position": "A", "status": 1, "statusColor": "#ffffff" },
      { "position": "B", "status": 1, "statusColor": "#ffffff" },
      { "position": "C", "status": 1, "statusColor": "#ffffff" },
      { "position": "D", "status": 1, "statusColor": "#ffffff" },
      { "position": "E", "status": 1, "statusColor": "#ffffff" },
      { "position": "F", "status": 1, "statusColor": "#ffffff" },
      { "position": "G", "status": 1, "statusColor": "#ffffff" },
      { "position": "H", "status": 1, "statusColor": "#ffffff" },
      { "position": "I", "status": 1, "statusColor": "#ffffff" },
      { "position": "J", "status": 1, "statusColor": "#ffffff" },
      { "position": "K", "status": 1, "statusColor": "#ffffff" },
      { "position": "L", "status": 1, "statusColor": "#ffffff" },
      { "position": "M", "status": 1, "statusColor": "#ffffff" },
      { "position": "N", "status": 1, "statusColor": "#ffffff" },
      { "position": "O", "status": 1, "statusColor": "#ffffff" },
      { "position": "P", "status": 1, "statusColor": "#ffffff" },
      { "position": "Q", "status": 1, "statusColor": "#ffffff" },
      { "position": "R", "status": 1, "statusColor": "#ffffff" },
      { "position": "S", "status": 1, "statusColor": "#ffffff" },
      { "position": "T", "status": 1, "statusColor": "#ffffff" },
      { "position": "U", "status": 1, "statusColor": "#ffffff" }
     ],
     "fireAlarm": false
    }
   }
   lastBridgeStatus[bridgeId].status.forEach(element => {
    var i = _objCollect_bridge.findIndex(x => x.obj_type == element.position);
    if (i == -1) return;
    _objCollect_bridge[i].material.color.set(element.statusColor);
    //isHidden 是否隱藏。(true: 隱藏, false: 顯示)
    //isFlash 是否閃爍。(true: 閃爍, false: 不閃爍)
    if (element.isFlash)
     setFlash_bridge(element.position);
    else
     clearFlash_bridge(element.position);
    if (element.isHidden) {
     _objCollect_bridge[i].material.transparent = true;
     _objCollect_bridge[i].material.opacity = 0;
    }
    else {
     _objCollect_bridge[i].material.transparent = false;
     _objCollect_bridge[i].material.opacity = 1;
    }
   });
  }

  function setBridgeData() {
   bim_setBridgeData(JSON.parse(document.getElementById("json").value));
  }


  function bim_setBridgeData(bridgeData) {
   lastBridgeStatus[bridgeData.bridgeId] = bridgeData;
   document.getElementById("event").value = event_count + ':bim_setBridgeData\n' + document.getElementById("event").value;
   if (enterBridgeId != bridgeData.bridgeId) return;
   event_count++;
   bridgeData.status.forEach(element => {
    var i = _objCollect_bridge.findIndex(x => x.obj_type == element.position);
    if (i == -1) return;
    _objCollect_bridge[i].material.color.set(element.statusColor);
    //isHidden 是否隱藏。(true: 隱藏, false: 顯示)
    //isFlash 是否閃爍。(true: 閃爍, false: 不閃爍)
    if (element.isFlash)
     setFlash_bridge(element.position);
    else
     clearFlash_bridge(element.position);
    if (element.isHidden) {
     _objCollect_bridge[i].material.transparent = true;
     _objCollect_bridge[i].material.opacity = 0;
    }
    else {
     _objCollect_bridge[i].material.transparent = false;
     _objCollect_bridge[i].material.opacity = 1;
    }
   });

  }

  function ap_showBridgePositionInfo(bridgeId, position) {
   document.getElementById("event").value = event_count + ':ap_showBridgePositionInfo ' + bridgeId + ',' + position + '\n' + document.getElementById("event").value;
   event_count++;

  }

  function ap_didLeaveBridgeScene(bridgeId) {
   document.getElementById("event").value = event_count + ':ap_didLeaveBridgeScene ' + bridgeId + '\n' + document.getElementById("event").value;
   event_count++;

  }
 </script>
</body>

</html>