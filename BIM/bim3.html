<!DOCTYPE html>
<html lang="en">

<head>
 <meta charset="UTF-8">
 <title>bimModel</title>
 <script src="dat.gui.min.js"></script>
 <style>
  /* 设置 GUI 容器的样式 */
  .dg.main {
   position: absolute;
   top: 10px;
   right: 10px;
   z-index: 1000;
  }

  .label {
   z-index: 1000 !important;
   display: block;
   /* 确保层级足够高 */
  }

  .none {
   display: none !important;
  }


  #wind_label {
   position: absolute;
   bottom: 10px;
   left: 10px;
   background-color: rgba(83, 33, 33, 0.8);
   padding: 5px 10px;
   border-radius: 5px;
   z-index: 2000;
   width: 200px;
   font-size: 10px;
   color: white;
  }

  #bridge_label{
   position: absolute;
   top: 10px;
   left: 10px;
   background-color: rgba(0, 3, 173, 0.8);
   padding: 5px 10px;
   border-radius: 5px;
   z-index: 2000;
   width: 200px;
   font-size: 20px;
   color: white;

  }

  #backButton {
   position: absolute;
   bottom: 10px;
   left: 10px;
   background-color: rgba(83, 33, 33);
   padding: 5px 10px;
   border-radius: 5px;
   z-index: 2000;
   font-size: 10px;
   color: white;
  }

  #viewAButton {
   position: absolute;
   bottom: 40px;
   left: 10px;
   background-color: rgba(83, 33, 33);
   padding: 5px 10px;
   border-radius: 5px;
   z-index: 2000;
   font-size: 10px;
   color: white;
  }

  #viewBButton {
   position: absolute;
   bottom: 70px;
   left: 10px;
   background-color: rgba(83, 33, 33);
   padding: 5px 10px;
   border-radius: 5px;
   z-index: 2000;
   font-size: 10px;
   color: white;
  }

  #viewCButton {
   position: absolute;
   bottom: 100px;
   left: 10px;
   background-color: rgba(83, 33, 33);
   padding: 5px 10px;
   border-radius: 5px;
   z-index: 2000;
   font-size: 10px;
   color: white;
  }

  .fire {
   width: 30px;
   height: 30px;
  }
 </style>
</head>

<body>
 <div id="bimModel" style="width: 80vw; height: 80vh; position: absolute; top:0; left:0;">
  <div id="wind_label">10分鐘平均風速/10分鐘最大瞬間風速(KTS)<br />
   防護基準:瞬間風速達37節,不使用時應降低高度。<br />
   停橋基準:瞬間風速達48節。<br />
   綁橋基準:瞬間風速達55節。<br />
   瞬間風速達25節,暫停橋复服務。</div>
 </div>
 <div id="bimModel_bridge" style="visibility: hidden; width: 80vw; height: 80vh; position: absolute; top:0; left:0;">
  <div id="bridge_label"></div> 
  <button id="backButton">返回</button> <button id="viewAButton">前</button> <button id="viewBButton">中</button> <button
   id="viewCButton">後</button>
 </div>
 <div style=" position: absolute; top:80vh; left:0;">json:<br />
  <textarea id="json" style="width:200px; height:100px"></textarea><br />
  <button id="setOverallData">bim_setOverallData</button>
  <button id="setBridgeData">bim_setBridgeData</button>
 </div>
 <div style=" position: absolute; top:80vh; left:350px;">
  event:<br />
  <textarea id="event" style="width:200px; height:100px"></textarea>
 </div>
 <script type="module">
  bim_launchView('bimModel');
  var container = document.getElementById('bimModel');
  var container_bridge = document.getElementById('bimModel_bridge');
  import * as THREE from './three.js';
  import { OrbitControls } from './OrbitControls.js';

  import { OBJLoader } from './OBJLoader.js';
  import { STLLoader } from './STLLoader.js';
  import { CSS2DRenderer, CSS2DObject } from './CSS2DRenderer.js';

  //參數區
  let planeModels = {
   selectedModel: ''
  };

  let allModels = [
   null, 'A380', 'A350-900', 'A330-300', 'A321neo',
   '787-10', '777-300ER', '747-400F', '737-800'
  ];

  let bridgeAngles = {
   rotationA1: 0,
   rotationA2: 0,
   rotationA3: 0,
   rotationB1: 0,
   rotationB2: 0,
   rotationB3: 0,
   rotationC1: 0,
   rotationC2: 0,
   rotationC3: 0,
   rotationAS1: 1,
   rotationAS2: 1,
   rotationAS3: 1,
   rotationBS1: 1,
   rotationBS2: 1,
   rotationBS3: 1,
   rotationCS1: 1,
   rotationCS2: 1,
   rotationCS3: 1
  };

  let camera, scene, renderer, labelRenderer, controls, raycaster, mouse, light, axesHelper;

  let camPosX, camPosY, camPosZ, camRotX, camRotY, camRotZ, controlTargetX, controlTargetY, controlTargetZ;


  let camera_bridge, scene_bridge, renderer_bridge, labelRenderer_bridge, controls_bridge, raycaster_bridge, mouse_bridge, light_bridge, axesHelper_bridge;

  //根據方向建立三個空橋陣列存放3d object
  let bridge1 = [];
  let bridge2 = [];
  let bridge3 = [];

  //空橋代碼
  let bridge_code1 = ['C18', 'C17', 'C16', 'C15', 'C14', 'C13', 'C12', 'C11'];
  let bridge_code2 = ['D18', 'D17', 'D16', 'D15', 'D14', 'D13', 'D12', 'D11'];
  let bridge_code3 = ['F1', 'F2', 'F3', 'F4', 'F5'];

  //飛機暫存
  let bridge_planeModel1 = ['', '', '', '', '', '', '', ''];
  let bridge_planeModel2 = ['', '', '', '', '', '', '', ''];
  let bridge_planeModel3 = ['', '', '', '', ''];


  let bridgeAngles1 = {};
  let bridgeAngles2 = {};
  let bridgeAngles3 = {};

  let planeXYA = { x: 0, y: 0, a: 0 };

  let intervalId = {};

  let enterBridgeId;

  //滑鼠事件
  let labelInfo = {
   gateClick: 'None', gateDblClick: 'None', gateMouseover: 'None',
   bridgeClick: 'None', bridgeDblClick: 'None', bridgeMouseover: 'None', modelClick: 'None'
  };

  //操控面板
  let gui = new dat.GUI();

  //camera 設定
  let C = { "position": { "x": -1.5989615626517384, "y": 83.61388808536435, "z": -16.485932169549844 }, "rotation": { "_x": -1.5707963267671246, "_y": 0.0000010003774455482065, "_z": 1.5707685651481607, "_order": "XYZ" }, "zoom": 1, "quaternion": { "_x": -0.500006690265619, "_y": 0.4999933096309743, "_z": 0.49999280944919444, "_w": 0.500007190461285 }, "fov": 45, "aspect": 2.015748031496063, "near": 0.1, "far": 5000, "target": { "x": -1.5990452080995163, "y": 3.889352887216332e-15, "z": -16.48593217187198 } };

  //空橋1
  let bridgeData1 = [{ "index": 0, "name": "sphere", "obj_type": "AL1", "position": { "x": 6.2, "y": 0.5, "z": 7.3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 1, "name": "sphere", "obj_type": "AL2", "position": { "x": 6.2, "y": 0.5, "z": 9 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 2, "name": "sphere", "obj_type": "AL3", "position": { "x": 6.2, "y": 0.5, "z": 10.2 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 3, "name": "sphere", "obj_type": "BL1", "position": { "x": 7.1, "y": 0.5, "z": 8.5 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 4, "name": "sphere", "obj_type": "BL2", "position": { "x": 7.1, "y": 0.5, "z": 10.2 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 5, "name": "sphere", "obj_type": "BL3", "position": { "x": 7.1, "y": 0.5, "z": 11.4 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 6, "name": "sphere", "obj_type": "CL1", "position": { "x": 7.1, "y": 0.5, "z": 9.7 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 7, "name": "sphere", "obj_type": "CL2", "position": { "x": 7.1, "y": 0.5, "z": 11.4 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 8, "name": "sphere", "obj_type": "CL3", "position": { "x": 7.1, "y": 0.5, "z": 12.6 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 9, "name": "cube.stl", "obj_type": "label", "position": { "x": 2, "y": 0, "z": 9 }, "scale": { "x": 0.8, "y": 0.1, "z": 0.1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#990000", "center": null }, { "index": 10, "name": "cube.stl", "obj_type": "", "position": { "x": 6, "y": 0, "z": 10 }, "scale": { "x": 0.4, "y": 0.1, "z": 0.1 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#990000", "center": null }, { "index": 11, "name": "cube.stl", "obj_type": "A1", "position": { "x": 6, "y": 0, "z": 8 }, "scale": { "x": 0.08, "y": 0.08, "z": 0.08 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": null }, { "index": 12, "name": "cube.stl", "obj_type": "B1", "position": { "x": 6.5, "y": 0, "z": 8.3 }, "scale": { "x": 0.1, "y": 0.08, "z": 0.08 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": null }, { "index": 13, "name": "cube.stl", "obj_type": "C1", "position": { "x": 6.5, "y": 0, "z": 9.5 }, "scale": { "x": 0.1, "y": 0.08, "z": 0.08 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": null }, { "index": 14, "name": "Group_29.stl", "obj_type": "A4", "position": { "x": 5.8, "y": -0.3, "z": 10.5 }, "scale": { "x": 0.3, "y": 0.3, "z": 0.6 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 6.15, "y": 0, "z": 10.57 } }, { "index": 15, "name": "Group_29.stl", "obj_type": "B4", "position": { "x": 6.7, "y": -0.3, "z": 11.6 }, "scale": { "x": 0.3, "y": 0.3, "z": 0.6 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 7, "y": 0, "z": 11.6 } }, { "index": 16, "name": "Group_29.stl", "obj_type": "C4", "position": { "x": 6.7, "y": -0.3, "z": 12.8 }, "scale": { "x": 0.3, "y": 0.3, "z": 0.6 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 7, "y": 0, "z": 12.8 } }, { "index": 17, "name": "JetwayConnector.stl", "obj_type": "A2", "position": { "x": 6.2, "y": -1, "z": 7.3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 6.25, "y": 0, "z": 7.3 } }, { "index": 18, "name": "JetwayConnector.stl", "obj_type": "B2", "position": { "x": 7.1, "y": -1, "z": 8.5 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 7.12, "y": 0, "z": 8.5 } }, { "index": 19, "name": "JetwayConnector.stl", "obj_type": "C2", "position": { "x": 7.1, "y": -1, "z": 9.7 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 7.12, "y": 0, "z": 9.77 } }, { "index": 20, "name": "CLE_JetwayGen.stl", "obj_type": "A3", "position": { "x": 6, "y": -1, "z": 7.3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 6.21, "y": 0, "z": 7.3 } }, { "index": 21, "name": "CLE_JetwayGen.stl", "obj_type": "B3", "position": { "x": 6.9, "y": -1, "z": 8.6 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 6.21, "y": 0, "z": 8.6 } }, { "index": 22, "name": "CLE_JetwayGen.stl", "obj_type": "C3", "position": { "x": 6.9, "y": -1, "z": 9.8 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 6.21, "y": 0, "z": 7.3 } }, { "index": 23, "name": "building.stl", "obj_type": "building", "position": { "x": 4, "y": -1, "z": 0.5 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#008ddb", "center": null }];

  //空橋2
  let bridgeData2 = [{ "index": 0, "name": "sphere", "obj_type": "AL1", "position": { "x": -2.3, "y": 0.5, "z": 2.7 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 1, "name": "sphere", "obj_type": "AL2", "position": { "x": -2.3, "y": 0.5, "z": 4.2 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 2, "name": "sphere", "obj_type": "AL3", "position": { "x": -2.3, "y": 0.5, "z": 5.6 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 3, "name": "sphere", "obj_type": "BL1", "position": { "x": -3.7, "y": 0.5, "z": 1.6 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 4, "name": "sphere", "obj_type": "BL2", "position": { "x": -3.7, "y": 0.5, "z": 3.3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 5, "name": "sphere", "obj_type": "BL3", "position": { "x": -3.7, "y": 0.5, "z": 4.6 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 6, "name": "sphere", "obj_type": "CL1", "position": { "x": -3.7, "y": 0.5, "z": 0.3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 7, "name": "sphere", "obj_type": "CL2", "position": { "x": -3.7, "y": 0.5, "z": 2 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 8, "name": "sphere", "obj_type": "CL3", "position": { "x": -3.7, "y": 0.5, "z": 3.3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 9, "name": "cube.stl", "obj_type": "label", "position": { "x": 1.8, "y": 0, "z": 1 }, "scale": { "x": 0.8, "y": 0.1, "z": 0.1 }, "rotation": { "_x": 0, "_y": 3.141592653589793, "_z": 0, "_order": "XYZ" }, "color": "#990000", "center": null }, { "index": 10, "name": "cube.stl", "obj_type": "", "position": { "x": -2.7, "y": 0, "z": 2 }, "scale": { "x": 0.4, "y": 0.1, "z": 0.1 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#990000", "center": null }, { "index": 11, "name": "cube.stl", "obj_type": "A1", "position": { "x": -2.65, "y": 0, "z": 2.4 }, "scale": { "x": 0.08, "y": 0.08, "z": 0.08 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": null }, { "index": 12, "name": "cube.stl", "obj_type": "B1", "position": { "x": -3.5, "y": 0, "z": 1.8 }, "scale": { "x": 0.08, "y": 0.08, "z": 0.2 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": null }, { "index": 13, "name": "cube.stl", "obj_type": "C1", "position": { "x": -3.5, "y": 0, "z": 0.5 }, "scale": { "x": 0.08, "y": 0.08, "z": 0.2 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": null }, { "index": 14, "name": "JetwayConnector.stl", "obj_type": "A2", "position": { "x": -2.4, "y": -1, "z": 2.7 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": -2.46, "y": 0, "z": 2.68 } }, { "index": 15, "name": "JetwayConnector.stl", "obj_type": "B2", "position": { "x": -3.8, "y": -1, "z": 1.6 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": -3.83, "y": 0, "z": 1.64 } }, { "index": 16, "name": "JetwayConnector.stl", "obj_type": "C2", "position": { "x": -3.8, "y": -1, "z": 0.3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": -3.83, "y": 0, "z": 0.27 } }, { "index": 17, "name": "Group_29.stl", "obj_type": "A4", "position": { "x": -2.8, "y": -0.3, "z": 5.7 }, "scale": { "x": 0.3, "y": 0.3, "z": 0.6 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": -2.36, "y": 0, "z": 5.77 } }, { "index": 18, "name": "Group_29.stl", "obj_type": "B4", "position": { "x": -4.2, "y": -0.3, "z": 4.7 }, "scale": { "x": 0.3, "y": 0.3, "z": 0.6 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": -3.77, "y": 0, "z": 4.73 } }, { "index": 19, "name": "Group_29.stl", "obj_type": "C4", "position": { "x": -4.2, "y": -0.3, "z": 3.4 }, "scale": { "x": 0.3, "y": 0.3, "z": 0.6 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": -3.77, "y": 0, "z": 3.43 } }, { "index": 20, "name": "CLE_JetwayGen.stl", "obj_type": "A3", "position": { "x": -2.6, "y": -1, "z": 2.7 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": -2.46, "y": 0, "z": 2.68 } }, { "index": 21, "name": "CLE_JetwayGen.stl", "obj_type": "B3", "position": { "x": -4, "y": -1, "z": 1.6 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": -3.83, "y": 0, "z": 1.57 } }, { "index": 22, "name": "CLE_JetwayGen.stl", "obj_type": "C3", "position": { "x": -4, "y": -1, "z": 0.3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": -3.83, "y": 0, "z": 0.27 } }, { "index": 23, "name": "building.stl", "obj_type": "building", "position": { "x": -1, "y": -1, "z": 12 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 3.141592653589793, "_z": 0, "_order": "XYZ" }, "color": "#008ddb", "center": null }];

  //空橋3
  let bridgeData3 = [{ "index": 0, "name": "sphere", "obj_type": "AL1", "position": { "x": 0.8, "y": 0.5, "z": 4.3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 1, "name": "sphere", "obj_type": "AL2", "position": { "x": 0.8, "y": 0.5, "z": 5.4 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 2, "name": "sphere", "obj_type": "AL3", "position": { "x": 0.8, "y": 0.5, "z": 6.4 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 4, "name": "cube.stl", "obj_type": "label", "position": { "x": 0.5, "y": 0, "z": 4 }, "scale": { "x": 0.8, "y": 0.1, "z": 0.1 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#990000", "center": null }, { "index": 5, "name": "cube.stl", "obj_type": "A1", "position": { "x": 0.55, "y": 0, "z": 4 }, "scale": { "x": 0.08, "y": 0.08, "z": 0.08 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": null }, { "index": 6, "name": "Group_29.stl", "obj_type": "A4", "position": { "x": 0.4, "y": -0.3, "z": 6.5 }, "scale": { "x": 0.3, "y": 0.3, "z": 0.6 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 0.8, "y": 0, "z": 6.5 } }, { "index": 7, "name": "JetwayConnector.stl", "obj_type": "A2", "position": { "x": 0.75, "y": -0.3, "z": 4.4 }, "scale": { "x": 0.5, "y": 0.5, "z": 0.5 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": { "x": 0.73, "y": 0, "z": 4.4 } }, { "index": 8, "name": "CLE_JetwayGen.stl", "obj_type": "A3", "position": { "x": 0.6, "y": -1, "z": 4 }, "scale": { "x": 1, "y": 1, "z": 0.8 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#eeeeee", "center": null }, { "index": 9, "name": "building.stl", "obj_type": "building", "position": { "x": 5.7, "y": -1, "z": 0.5 }, "scale": { "x": 0.45, "y": 1, "z": 0.45 }, "rotation": { "_x": 0, "_y": -1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#008ddb" }];

  //主建築
  let mainBuilding = [{ "index": 0, "name": "cube.stl", "obj_type": "undefined", "position": { "x": -14, "y": -1, "z": -20 }, "scale": { "x": 0.2, "y": 0.5, "z": 8.1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#006600", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 1, "name": "cube.stl", "obj_type": "undefined", "position": { "x": 13, "y": -1, "z": -20 }, "scale": { "x": 0.2, "y": 0.5, "z": 8.1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#006600", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 2, "name": "cube.stl", "obj_type": "出境1", "position": { "x": -23, "y": 0.5, "z": -1 }, "scale": { "x": 2, "y": 0.2, "z": 0.4 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#880000", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 3, "name": "cube.stl", "obj_type": "入境2", "position": { "x": 12, "y": -0.5, "z": -1 }, "scale": { "x": 2, "y": 0.2, "z": 0.4 }, "rotation": { "_x": 0, "_y": 0.4363323129985824, "_z": 0, "_order": "XYZ" }, "color": "#880000", "center": { "x": 21.7, "y": 0, "z": 0 } }, { "index": 4, "name": "cube.stl", "obj_type": "入境1", "position": { "x": -23, "y": -0.5, "z": -1 }, "scale": { "x": 2.2, "y": 0.2, "z": 0.4 }, "rotation": { "_x": 0, "_y": -0.4363323129985824, "_z": 0, "_order": "XYZ" }, "color": "#880000", "center": { "x": -22.5, "y": 0, "z": 0.1 } }, { "index": 5, "name": "cube.stl", "obj_type": "出境2", "position": { "x": 12, "y": 0.5, "z": -1 }, "scale": { "x": 2, "y": 0.2, "z": 0.4 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#880000", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 6, "name": "cube.stl", "obj_type": "", "position": { "x": -52, "y": -1.1, "z": -90 }, "scale": { "x": 20, "y": 0.05, "z": 30 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#dddddd", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 7, "name": "cube.stl", "obj_type": "undefined", "position": { "x": -14, "y": 0.5, "z": -20 }, "scale": { "x": 5.5, "y": 0.02, "z": 8 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#dddddd", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 8, "name": "cube.stl", "obj_type": "undefined", "position": { "x": -14, "y": 1.5, "z": -20 }, "scale": { "x": 5.5, "y": 0.1, "z": 8 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#dddddd", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 9, "name": "pillar.stl", "obj_type": "undefined", "position": { "x": -20, "y": -1, "z": -6 }, "scale": { "x": 1, "y": 1.6, "z": 1 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#888888", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 10, "name": "pillar.stl", "obj_type": "undefined", "position": { "x": -20, "y": -1, "z": 4 }, "scale": { "x": 1, "y": 1.6, "z": 1 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#888888", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 11, "name": "pillar.stl", "obj_type": "undefined", "position": { "x": 20, "y": -1, "z": -6 }, "scale": { "x": 1, "y": 1.6, "z": 1 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#888888", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 12, "name": "pillar.stl", "obj_type": "undefined", "position": { "x": 20, "y": -1, "z": 4 }, "scale": { "x": 1, "y": 1.6, "z": 1 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#888888", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 13, "name": "top3.stl", "obj_type": "undefined", "position": { "x": 0, "y": 2, "z": 0 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#888888", "center": { "x": 0, "y": 0, "z": 0 } }];

  //飛機模型
  let planeData = [{ "index": 0, "name": "a380.stl", "obj_type": "A380", "position": { "x": -9, "y": -1, "z": 0 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ffffff", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 1, "name": "a350-900.stl", "obj_type": "A350-900", "position": { "x": -17, "y": -1, "z": 0 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ffffff", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 2, "name": "a330-300.stl", "obj_type": "A330-300", "position": { "x": -25, "y": -1, "z": 0 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ffffff", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 3, "name": "a321neo.stl", "obj_type": "A321neo", "position": { "x": -33, "y": -1, "z": 0 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ffffff", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 4, "name": "787-8.stl", "obj_type": "787-10", "position": { "x": -41, "y": -1, "z": 0 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ffffff", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 5, "name": "777.stl", "obj_type": "777-300ER", "position": { "x": -50, "y": -1, "z": 0 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ffffff", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 6, "name": "747-400.stl", "obj_type": "747-400F", "position": { "x": -59, "y": -1, "z": 0 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ffffff", "center": { "x": 0, "y": 0, "z": 0 } }, { "index": 7, "name": "B737.stl", "obj_type": "737-800", "position": { "x": -69, "y": -1, "z": 0 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ffffff", "center": { "x": 0, "y": 0, "z": 0 } }];

  let _objPlaneCollect = [, , , , , , ,]; //飛機模型

  let gui_bridge = new dat.GUI();

  var colors_bridge = {};

  //camera 設定
  let C_bridgeC = { "position": { "x": -31.138908642283276, "y": 21.124547046100854, "z": 20.02802432713419 }, "rotation": { "_x": -0.6343495415501454, "_y": -1.1304057886682897, "_z": -0.5872580951896136, "_order": "XYZ" }, "zoom": 1, "quaternion": { "_x": -0.10482487807797901, "_y": -0.5633217718122143, "_z": -0.07233320219154937, "_w": 0.8163628079469328 }, "fov": 45, "aspect": 2.015748031496063, "near": 0.1, "far": 5000, "target": { "x": 44.496981100130974, "y": 3.4989089747618552e-15, "z": -8.681694858696433 } };

  let C_bridgeB = { "position": { "x": 22.071359802592823, "y": 24.78459126863992, "z": 41.47852024594192 }, "rotation": { "_x": -0.3937047515318204, "_y": 0.052870469233824054, "_z": 0.021948228935150135, "_order": "XYZ" }, "zoom": 1, "quaternion": { "_x": -0.19521890077614165, "_y": 0.028065674655406155, "_z": 0.005588814423002102, "_w": 0.980342115712284 }, "fov": 45, "aspect": 2.1044520547945207, "near": 0.1, "far": 5000, "target": { "x": 18.652295555277366, "y": 3.5489485507749723e-15, "z": -18.186988965429887 } };

  let C_bridgeA = { "position": { "x": 57.616532220088516, "y": 25.81896852127743, "z": -1.908670778081924 }, "rotation": { "_x": -1.5594513113168036, "_y": 0.9968965660789258, "_z": 1.557287223169511, "_order": "XYZ" }, "zoom": 1, "quaternion": { "_x": -0.20084950068515345, "_y": 0.6757069456808736, "_z": 0.19938182868205784, "_w": 0.680680900293631 }, "fov": 45, "aspect": 2.1044520547945207, "near": 0.1, "far": 5000, "target": { "x": 17.67645964620174, "y": 3.3247819950130667e-15, "z": -2.201599943268754 } };
  //空橋1
  let bridgeData = [{ "index": 0, "name": "sphere", "obj_type": "A", "position": { "x": -1.8, "y": 10, "z": 2.4 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 1, "name": "sphere", "obj_type": "B", "position": { "x": 0.4, "y": 4, "z": -3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 2, "name": "sphere", "obj_type": "C", "position": { "x": 0, "y": 1, "z": -3.5 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 3, "name": "sphere", "obj_type": "D", "position": { "x": 2, "y": 14, "z": -1.5 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 4, "name": "sphere", "obj_type": "E", "position": { "x": 0, "y": 13, "z": -2 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 5, "name": "sphere", "obj_type": "F", "position": { "x": 12, "y": 8, "z": 0.49 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 6, "name": "sphere", "obj_type": "G", "position": { "x": 25.4, "y": 5, "z": 0.5 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 7, "name": "sphere", "obj_type": "H", "position": { "x": 25.3, "y": 3, "z": -2 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 8, "name": "sphere", "obj_type": "I", "position": { "x": 14, "y": 12, "z": 0 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 9, "name": "sphere", "obj_type": "J", "position": { "x": 33, "y": 10, "z": -2 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 10, "name": "sphere", "obj_type": "K", "position": { "x": 33, "y": 9, "z": -4 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff0000", "center": null }, { "index": 11, "name": "sphere", "obj_type": "L", "position": { "x": 33.5, "y": 7, "z": -2 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ffffee", "center": null }, { "index": 12, "name": "sphere", "obj_type": "M", "position": { "x": 26, "y": 5, "z": 1.6 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ffffff", "center": null }, { "index": 13, "name": "sphere", "obj_type": "N", "position": { "x": 34, "y": 12, "z": -2 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ffff00", "center": null }, { "index": 14, "name": "sphere", "obj_type": "O", "position": { "x": 5, "y": 11, "z": 0 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#00ffff", "center": null }, { "index": 15, "name": "sphere", "obj_type": "P", "position": { "x": 10, "y": 5, "z": 0 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 16, "name": "sphere", "obj_type": "Q", "position": { "x": 9.1, "y": 12, "z": 0 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 17, "name": "sphere", "obj_type": "R", "position": { "x": 16, "y": 5, "z": 0.3 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 18, "name": "sphere", "obj_type": "S", "position": { "x": 20.4, "y": 6, "z": 0.2 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 19, "name": "sphere", "obj_type": "T", "position": { "x": 24, "y": 6, "z": 0.2 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 20, "name": "sphere", "obj_type": "U", "position": { "x": 23, "y": 4, "z": 0.2 }, "scale": { "x": 1, "y": 1, "z": 1 }, "rotation": { "_x": 0, "_y": 0, "_z": 0, "_order": "XYZ" }, "color": "#ff00ee", "center": null }, { "index": 21, "name": "a380.stl", "obj_type": "", "position": { "x": 45, "y": 0, "z": 19 }, "scale": { "x": 10, "y": 10, "z": 10 }, "rotation": { "_x": 0, "_y": 3.141592653589793, "_z": 0, "_order": "XYZ" }, "color": "#ffff99", "center": null }, { "index": 22, "name": "JetwayDetail.stl", "obj_type": "Jetway", "position": { "x": 0, "y": 0, "z": 0 }, "scale": { "x": 10, "y": 10, "z": 10 }, "rotation": { "_x": 0, "_y": 1.5707963267948966, "_z": 0, "_order": "XYZ" }, "color": "#ffffff", "center": { "x": 0, "y": 0, "z": 0 } }];


  let _objCollect_bridge = [];

  let _collect_intervalId = {};

  let _collect_intervalId_bridge = {};

  //Method區

  function scalePoint(px, py, pz, cx, cy, cz, sx = 1, sy = 1, sz = 1) {
   // 创建点的三维向量
   let pointVector = new THREE.Vector3(px, py, pz);

   // 创建中心点的三维向量
   let centerVector = new THREE.Vector3(cx, cy, cz);

   // 计算从中心点到点的向量
   let offsetVector = new THREE.Vector3().subVectors(pointVector, centerVector);

   // 应用缩放
   offsetVector.x *= sx;
   offsetVector.y *= sy;
   offsetVector.z *= sz;

   // 计算新位置
   let newPointVector = centerVector.clone().add(offsetVector);

   // 返回新的坐标
   return newPointVector;
  }


  function rotatePoint(px, py, pz, cx, cy, cz, rx, ry, rz) {
   // 将角度从度转换为弧度
   rx = rx * Math.PI / 180;
   ry = ry * Math.PI / 180;
   rz = rz * Math.PI / 180;

   // 创建点的三维向量
   let pointVector = new THREE.Vector3(px, py, pz);

   // 创建中心点的三维向量
   let centerVector = new THREE.Vector3(cx, cy, cz);

   // 计算相对于中心点的向量
   pointVector.sub(centerVector);

   // 创建一个空的四元数用于旋转
   let quaternion = new THREE.Quaternion();

   // 绕 Y 轴旋转
   quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), ry);
   pointVector.applyQuaternion(quaternion);

   // 将旋转后的点向量加回中心点向量，恢复其世界坐标
   pointVector.add(centerVector);

   // 返回旋转后的点坐标
   return pointVector;
  }



  //重設
  function resetCameraAndControls() {
   // 设置相机的默认位置和旋转
   camera.position.set(C.position.x, C.position.y, C.position.z); // 初始位置
   camera.rotation.set(C.rotation._x, C.rotation._y, C.rotation._z); // 初始旋转

   // 设置控制器的目标点
   controls.target.set(C.target.x, C.target.y, C.target.z);

   // 更新控制器和相机
   controls.update();

   let sumX = 0, sumY = 0, sumZ = 0;
   let count = 0;

   // 计算所有对象的坐标平均值
   scene.traverse(function (object) {
    if (object.isMesh) {
     sumX += object.position.x;
     sumY += object.position.y;
     sumZ += object.position.z;
     count++;
    }
   });

   const centerX = sumX / count;
   const centerY = sumY / count;
   const centerZ = sumZ / count;

   // 设置摄像机看向新的中心点
   camera.lookAt(centerX, centerY, centerZ);
   camera.updateProjectionMatrix();

   // 同步更新 GUI 显示
   camPosX.setValue(camera.position.x);
   camPosY.setValue(camera.position.y);
   camPosZ.setValue(camera.position.z);
   camRotX.setValue(camera.rotation.x);
   camRotY.setValue(camera.rotation.y);
   camRotZ.setValue(camera.rotation.z);
   controlTargetX.setValue(controls.target.x);
   controlTargetY.setValue(controls.target.y);
   controlTargetZ.setValue(controls.target.z);
  }



  //清空空橋
  function clearAllplane() {
   bridge1.forEach(function (subArray, index) {
    bridge_planeModel1[index] = '';
    bridge1[index] = subArray.filter(function (item) {
     if (item.obj_type == 'plane') scene.remove(item);
     return item.obj_name !== 'a380.stl';  // 只保留 object_name 不等于 'xxx' 的对象
    });
    setPlaneData(bridge_code1[index], '');
    setWindData(bridge_code1[index], '');
   });
   bridge2.forEach(function (subArray, index) {
    bridge_planeModel2[index] = '';
    bridge2[index] = subArray.filter(function (item) {
     if (item.obj_type == 'plane') scene.remove(item);
     return item.obj_name !== 'a380.stl';  // 只保留 object_name 不等于 'xxx' 的对象
    });
    setPlaneData(bridge_code2[index], '');
    setWindData(bridge_code2[index], '');
   });
   bridge3.forEach(function (subArray, index) {
    bridge_planeModel3[index] = '';
    bridge3[index] = subArray.filter(function (item) {
     if (item.obj_type == 'plane') scene.remove(item);
     return item.obj_name !== 'a380.stl';  // 只保留 object_name 不等于 'xxx' 的对象
    });
    setPlaneData(bridge_code3[index], '');
    setWindData(bridge_code3[index], '');
   });


   //重設空橋
   for (var c = 0; c < 8; c++) {
    rotateBridge(bridgeData1, bridge1[c], c, 'A', 180, 180, 0.2, 0.6, 20, 0, -20, 10);
    rotateBridge(bridgeData1, bridge1[c], c, 'B', 90, 0, 0.2, 0.6, 20, 0, -20, 10);
    rotateBridge(bridgeData1, bridge1[c], c, 'C', 90, 0, 0.2, 0.6, 20, 0, -20, 10);
    bridgeAngles1[bridge_code1[c]] = { 'A2': 180, 'A3': 180, 'B2': 90, 'B3': 0, 'C2': 90, 'C3': 0, 'AS2': 0.2, 'AS3': 0.6, 'BS2': 0.2, 'BS3': 0.6, 'CS2': 0.2, 'CS3': 0.6 };
   }
   for (var c = 0; c < 8; c++) {
    rotateBridge(bridgeData2, bridge2[c], c, 'A', 0, 0, 0.2, 0.6, -25, 0, -20, 10);
    rotateBridge(bridgeData2, bridge2[c], c, 'B', -90, 0, 0.2, 0.6, -25, 0, -20, 10);
    rotateBridge(bridgeData2, bridge2[c], c, 'C', -90, 0, 0.2, 0.6, -25, 0, -20, 10);
    bridgeAngles2[bridge_code2[c]] = { 'A2': 0, 'A3': 0, 'B2': -90, 'B3': 0, 'C2': -90, 'C3': 0, 'AS2': 0.2, 'AS3': 0.6, 'BS2': 0.2, 'BS3': 0.6, 'CS2': 0.2, 'CS3': 0.6 };
   }
   for (var c = 0; c < 5; c++) {
    rotateBridge(bridgeData3, bridge3[c], c, 'A', 160, -70, 0.2, 0.6, -12, 5, -23, 0);
    bridgeAngles3[bridge_code3[c]] = { 'A2': 160, 'A3': -70, 'AS2': 0.2, 'AS3': 0.6 };
   }

  }

  function setBridgeAngle(ABC) {
   var no = labelInfo.gateClick;

   var i1 = bridge_code1.findIndex(x => x == no);
   var i2 = bridge_code2.findIndex(x => x == no);
   var i3 = bridge_code3.findIndex(x => x == no);

   if (i1 > -1) {
    bridgeAngles1[bridge_code1[i1]] = {
     'A2': bridgeAngles.rotationA2, 'A3': bridgeAngles.rotationA3,
     'B2': bridgeAngles.rotationB2, 'B3': bridgeAngles.rotationB3,
     'C2': bridgeAngles.rotationC2, 'C3': bridgeAngles.rotationC3,
     'AS2': bridgeAngles.rotationAS2, 'AS3': bridgeAngles.rotationAS3,
     'BS2': bridgeAngles.rotationBS2, 'BS3': bridgeAngles.rotationBS3,
     'CS2': bridgeAngles.rotationCS2, 'CS3': bridgeAngles.rotationCS3
    };
    if (ABC == 'A')
     rotateBridge(bridgeData1, bridge1[i1], i1, ABC,
      bridgeAngles.rotationA2, bridgeAngles.rotationA3,
      bridgeAngles.rotationAS2, bridgeAngles.rotationAS3,
      20, 0, -20, 10);
    if (ABC == 'B')
     rotateBridge(bridgeData1, bridge1[i1], i1, ABC,
      bridgeAngles.rotationB2, bridgeAngles.rotationB3,
      bridgeAngles.rotationBS2, bridgeAngles.rotationBS3,
      20, 0, -20, 10);
    if (ABC == 'C')
     rotateBridge(bridgeData1, bridge1[i1], i1, ABC,
      bridgeAngles.rotationC2, bridgeAngles.rotationC3,
      bridgeAngles.rotationCS2, bridgeAngles.rotationCS3,
      20, 0, -20, 10);
   }
   if (i2 > -1) {
    bridgeAngles2[bridge_code2[i2]] = {
     'A2': bridgeAngles.rotationA2, 'A3': bridgeAngles.rotationA3,
     'B2': bridgeAngles.rotationB2, 'B3': bridgeAngles.rotationB3,
     'C2': bridgeAngles.rotationC2, 'C3': bridgeAngles.rotationC3,
     'AS2': bridgeAngles.rotationAS2, 'AS3': bridgeAngles.rotationAS3,
     'BS2': bridgeAngles.rotationBS2, 'BS3': bridgeAngles.rotationBS3,
     'CS2': bridgeAngles.rotationCS2, 'CS3': bridgeAngles.rotationCS3
    };
    if (ABC == 'A')
     rotateBridge(bridgeData2, bridge2[i2], i2, ABC,
      bridgeAngles.rotationA2, bridgeAngles.rotationA3,
      bridgeAngles.rotationAS2, bridgeAngles.rotationAS3,
      -25, 0, -20, 10);
    if (ABC == 'B')
     rotateBridge(bridgeData2, bridge2[i2], i2, ABC,
      bridgeAngles.rotationB2, bridgeAngles.rotationB3,
      bridgeAngles.rotationBS2, bridgeAngles.rotationBS3,
      -25, 0, -20, 10);
    if (ABC == 'C')
     rotateBridge(bridgeData2, bridge2[i2], i2, ABC,
      bridgeAngles.rotationC2, bridgeAngles.rotationC3,
      bridgeAngles.rotationCS2, bridgeAngles.rotationCS3,
      -25, 0, -20, 10);
   }

   if (i3 > -1) {
    bridgeAngles3[bridge_code3[i3]] = {
     'A2': bridgeAngles.rotationA2, 'A3': bridgeAngles.rotationA3,
     'AS2': bridgeAngles.rotationAS2, 'AS3': bridgeAngles.rotationAS3,
    };
    rotateBridge(bridgeData3, bridge3[i3], i3, ABC,
     bridgeAngles.rotationA2, bridgeAngles.rotationA3,
     bridgeAngles.rotationAS2, bridgeAngles.rotationAS3,
     -12, 5, -23, 0);
   }
  }


  function runBridge(no, A2, A3, B2, B3, C2, C3, AS2, AS3, BS2, BS3, CS2, CS3) {

   var i1 = bridge_code1.findIndex(x => x == no);
   var i2 = bridge_code2.findIndex(x => x == no);
   var i3 = bridge_code3.findIndex(x => x == no);

   if (i1 > -1) {
    bridgeAngles1[bridge_code1[i1]] = {
     'A2': A2, 'A3': A3,
     'B2': B2, 'B3': B3,
     'C2': C2, 'C3': C3,
     'AS2': AS2, 'AS3': AS3,
     'BS2': BS2, 'BS3': BS3,
     'CS2': CS2, 'CS3': CS3
    };
    rotateBridge(bridgeData1, bridge1[i1], i1, 'A',
     A2, A3,
     AS2, AS3,
     20, 0, -20, 10);
    rotateBridge(bridgeData1, bridge1[i1], i1, 'B',
     B2, B3,
     BS2, BS3,
     20, 0, -20, 10);
    rotateBridge(bridgeData1, bridge1[i1], i1, 'C',
     C2, C3,
     CS2, CS3,
     20, 0, -20, 10);
   }
   if (i2 > -1) {
    bridgeAngles2[bridge_code2[i2]] = {
     'A2': A2, 'A3': A3,
     'B2': B2, 'B3': B3,
     'B2': C2, 'B3': C3,
     'AS2': AS2, 'AS3': AS3,
     'BS2': BS2, 'BS3': BS3,
     'CS2': CS2, 'CS3': CS3
    };
    rotateBridge(bridgeData2, bridge2[i2], i2, 'A',
     A2 - 180, A3,
     AS2, AS3,
     -25, 0, -20, 10);
    rotateBridge(bridgeData2, bridge2[i2], i2, 'B',
     B2 - 180, B3,
     BS2, BS3,
     -25, 0, -20, 10);
    rotateBridge(bridgeData2, bridge2[i2], i2, 'C',
     B2 - 180, B3,
     BS2, BS3,
     -25, 0, -20, 10);
   }

   if (i3 > -1) {
    bridgeAngles3[bridge_code3[i3]] = {
     'A2': A2, 'A3': A3,
     'AS2': AS2, 'AS3': AS3,
    };
    rotateBridge(bridgeData3, bridge3[i3], i3, 'A',
     A2 - 90, A3,
     AS2, AS3,
     -12, 5, -23, 0);
   }
  }

  function runPlaneXYA(no, px, py, pa) {
   var xOffset = 0, xIncrement = 0, zOffset = 0, zIncrement = 0;
   var i1 = bridge_code1.findIndex(x => x == no);
   var i2 = bridge_code2.findIndex(x => x == no);
   var i3 = bridge_code3.findIndex(x => x == no);

   if (i1 > -1) {
    var i = bridge1[i1].findIndex(x => x.obj_type == 'plane');
    bridge1[i1][i].rotation.set(bridge1[i1][i].rotation._x, pa / 180 * Math.PI, bridge1[i1][i].rotation._z);
    bridge1[i1][i].position.set(px, -1, py);
   }
   if (i2 > -1) {
    var i = bridge2[i2].findIndex(x => x.obj_type == 'plane');
    bridge2[i2][i].rotation.set(bridge2[i2][i].rotation._x, pa / 180 * Math.PI, bridge2[i2][i].rotation._z);
    bridge2[i2][i].position.set(px, -1, py);
   }
   if (i3 > -1) {
    var i = bridge3[i3].findIndex(x => x.obj_type == 'plane');
    bridge3[i3][i].rotation.set(bridge3[i3][i].rotation._x, pa / 180 * Math.PI, bridge3[i3][i].rotation._z);
    bridge3[i3][i].position.set(px, -1, py);
   }
  }

  function setPlaneXYA() {
   var no = labelInfo.gateClick;
   var i1 = bridge_code1.findIndex(x => x == no);
   var i2 = bridge_code2.findIndex(x => x == no);
   var i3 = bridge_code3.findIndex(x => x == no);

   if (i1 > -1) {
    var i = bridge1[i1].findIndex(x => x.obj_type == 'plane');
    bridge1[i1][i].rotation.set(bridge1[i1][i].rotation._x, planeXYA.a / 180 * Math.PI, bridge1[i1][i].rotation._z);
    bridge1[i1][i].position.set(planeXYA.x, -1, planeXYA.y);
   }
   if (i2 > -1) {
    var i = bridge2[i2].findIndex(x => x.obj_type == 'plane');
    bridge2[i2][i].rotation.set(bridge2[i2][i].rotation._x, planeXYA.a / 180 * Math.PI, bridge2[i2][i].rotation._z);
    bridge2[i2][i].position.set(planeXYA.x, -1, planeXYA.y);
   }
   if (i3 > -1) {
    var i = bridge3[i3].findIndex(x => x.obj_type == 'plane');
    bridge3[i3][i].rotation.set(bridge3[i3][i].rotation._x, planeXYA.a / 180 * Math.PI, bridge3[i3][i].rotation._z);
    bridge3[i3][i].position.set(planeXYA.x, -1, planeXYA.y);
   }
  }
  //設定飛機
  function setPlane(no, m) {
   if (!no) no = labelInfo.gateClick;
   clearPlane(no);
   if (!m) m = planeModels.selectedModel;
   var i1 = bridge_code1.findIndex(x => x == no);
   var i2 = bridge_code2.findIndex(x => x == no);
   var i3 = bridge_code3.findIndex(x => x == no);

   var i = planeData.findIndex(x => x.obj_type == m);
   if (i == -1) i = 0;
   /*
 function addModel(_objCollect, labelData, name, c, 
 position, rotation, center, scale, color, 
 xOffset = 0, xIncrement = 0, zOffset = 0, zIncrement = 0)*/
   if (i > -1) {
    if (i1 > -1) {
     addModel(bridge1, bridge_code1, _objPlaneCollect[i], i1,
      { x: 0, y: 0, z: 0 }, { _x: 0, _y: 0, _z: 0 }, null, { x: 1, y: 1, z: 1 }, '#ffffff',
      20, 0, -20, 10);
     bridge_planeModel1[i1] = m;
    }
    if (i2 > -1) {
     addModel(bridge2, bridge_code2, _objPlaneCollect[i], i2,
      { x: 0, y: 0, z: 0 }, { _x: 0, _y: 0, _z: 0 }, null, { x: 1, y: 1, z: 1 }, '#ffffff',
      -25, 0, -20, 10);
     bridge_planeModel2[i2] = m;
    }
    if (i3 > -1) {
     addModel(bridge3, bridge_code3, _objPlaneCollect[i], i3,
      { x: 0, y: 0, z: 0 }, { _x: 0, _y: 0, _z: 0 }, null, { x: 1, y: 1, z: 1 }, '#ffffff',
      50, 0, 80, 70);
     bridge_planeModel3[i3] = m;
    }
   }
  }

  //清除飛機
  function clearPlane(no) {
   var i1 = bridge_code1.findIndex(x => x == no);
   var i2 = bridge_code2.findIndex(x => x == no);
   var i3 = bridge_code3.findIndex(x => x == no);
   if (i1 > -1) {
    var p1 = bridge1[i1].findIndex(x => x.obj_type == 'plane');
    if (p1 > -1) {
     scene.remove(bridge1[i1][p1]);
     bridge1[i1].splice(p1, 1);
     bridge_planeModel1[p1] = '';
    }
   }
   else if (i2 > -1) {
    var p2 = bridge2[i2].findIndex(x => x.obj_type == 'plane');
    if (p2 > -1) {
     scene.remove(bridge2[i2][p2]);
     bridge2[i2].splice(p2, 1);
     bridge_planeModel2[p2] = '';
    }
   }
   else if (i3 > -1) {
    var p3 = bridge3[i3].findIndex(x => x.obj_type == 'plane');
    if (p3 > -1) {
     scene.remove(bridge3[i3][p3]);
     bridge3[i3].splice(p3, 1);
     bridge_planeModel3[p3] = '';
    }
   }
  }

  //
  function rotateBridge(tmp, stlModels, c, N, A2, A4, SA3, SA4, xOffset = 0, xIncrement = 0, zOffset = 0, zIncrement = 0) {

   //找原始設定
   if (!tmp) return;
   var idxA1 = JSON.parse(JSON.stringify(tmp[tmp.findIndex(x => x.obj_type && x.obj_type == N + '1')]));
   var idxA2 = JSON.parse(JSON.stringify(tmp[tmp.findIndex(x => x.obj_type && x.obj_type == N + '2')]));
   var idxA3 = JSON.parse(JSON.stringify(tmp[tmp.findIndex(x => x.obj_type && x.obj_type == N + '3')]));
   var idxA4 = JSON.parse(JSON.stringify(tmp[tmp.findIndex(x => x.obj_type && x.obj_type == N + '4')]));

   var idxAL1 = JSON.parse(JSON.stringify(tmp[tmp.findIndex(x => x.obj_type && x.obj_type == N + 'L1')]));
   var idxAL2 = JSON.parse(JSON.stringify(tmp[tmp.findIndex(x => x.obj_type && x.obj_type == N + 'L2')]));
   var idxAL3 = JSON.parse(JSON.stringify(tmp[tmp.findIndex(x => x.obj_type && x.obj_type == N + 'L3')]));

   var stlModel1 = stlModels[stlModels.findIndex(x => x.obj_type && x.obj_type == N + '1')];
   var stlModel2 = stlModels[stlModels.findIndex(x => x.obj_type && x.obj_type == N + '2')];
   var stlModel3 = stlModels[stlModels.findIndex(x => x.obj_type && x.obj_type == N + '3')];
   var stlModel4 = stlModels[stlModels.findIndex(x => x.obj_type && x.obj_type == N + '4')];
   var stlModelL2 = stlModels[stlModels.findIndex(x => x.obj_type && x.obj_type == N + 'L2')];
   var stlModelL3 = stlModels[stlModels.findIndex(x => x.obj_type && x.obj_type == N + 'L3')];


   var centerA2 = idxA2.center;
   var centerA3 = idxA3.center;
   var centerA4 = idxA4.center;
   var rotateA1 = idxA1.rotation;
   var rotateA2 = idxA2.rotation;
   var rotateA3 = idxA3.rotation;
   var rotateA4 = idxA4.rotation;
   var posA1 = idxA1.position;
   var posA2 = idxA2.position;
   var posA3 = idxA3.position;
   var posAL2 = idxAL2.position;
   var posAL3 = idxAL3.position;
   var posA4 = idxA4.position;
   var scaleA1 = idxA1.scale;
   var scaleA2 = idxA2.scale;
   var scaleA3 = idxA3.scale;
   var scaleA4 = idxA4.scale;




   var newPosA2 = rotatePoint(posA2.x, posA2.y, posA2.z, centerA2.x, centerA2.y, centerA2.z, 0, A2, 0);
   idxA2.rotation = { _x: 0, _y: A2 / 180 * Math.PI, _z: 0 };
   idxA2.position = { x: newPosA2.x, y: newPosA2.y, z: newPosA2.z };


   var newPosA3 = rotatePoint(posA3.x, posA3.y, posA3.z + SA3, centerA2.x, centerA2.y, centerA2.z, 0, A2, 0);
   idxA3.rotation = { _x: 0, _y: A2 / 180 * Math.PI, _z: 0 };
   idxA3.position = { x: newPosA3.x, y: newPosA3.y, z: newPosA3.z };

   var newPosA4 = rotatePoint(posA4.x, posA4.y, posA4.z + SA3, centerA2.x, centerA2.y, centerA2.z, 0, A2, 0);
   idxA4.rotation = { _x: 0, _y: (A2 + A4) / 180 * Math.PI, _z: 0 };
   idxA4.position = { x: newPosA4.x, y: newPosA4.y, z: newPosA4.z };


   var newPosAL2 = rotatePoint(posAL2.x, posAL2.y, posAL2.z, centerA2.x, centerA2.y, centerA2.z, 0, A2, 0);
   idxAL2.position = { x: newPosAL2.x, y: newPosAL2.y, z: newPosAL2.z };


   var newPosAL3 = rotatePoint(posAL3.x, posAL3.y, posAL3.z + SA3, centerA2.x, centerA2.y, centerA2.z, 0, A2, 0);
   idxAL3.position = { x: newPosAL3.x, y: newPosAL3.y, z: newPosAL3.z };


   var newCenterA4 = rotatePoint(centerA4.x, centerA4.y, centerA4.z + SA3, centerA2.x, centerA2.y, centerA2.z, 0, A2, 0);

   newPosA4 = rotatePoint(newPosA4.x, newPosA4.y, newPosA4.z, newCenterA4.x, newCenterA4.y, newCenterA4.z, rotateA4._x * 180 / Math.PI, A4, rotateA4._z * 180 / Math.PI);

   idxA4.position = { x: newPosA4.x, y: newPosA4.y, z: newPosA4.z };
   idxA4.scale = { x: 0.35, y: 0.35, z: SA4 };

   stlModel2.rotation.set(idxA2.rotation._x, idxA2.rotation._y, idxA2.rotation._z);
   stlModel3.rotation.set(idxA3.rotation._x, idxA3.rotation._y, idxA3.rotation._z);
   stlModel4.rotation.set(idxA4.rotation._x, idxA4.rotation._y, idxA4.rotation._z);
   stlModel2.position.set(idxA2.position.x + xOffset + c * xIncrement, idxA2.position.y, idxA2.position.z - zOffset - c * zIncrement);
   stlModel3.position.set(idxA3.position.x + xOffset + c * xIncrement, idxA3.position.y, idxA3.position.z - zOffset - c * zIncrement);
   stlModel4.position.set(idxA4.position.x + xOffset + c * xIncrement, idxA4.position.y, idxA4.position.z - zOffset - c * zIncrement);
   stlModelL2.position.set(idxAL2.position.x + xOffset + c * xIncrement, idxAL2.position.y, idxAL2.position.z - zOffset - c * zIncrement);
   stlModelL3.position.set(idxAL3.position.x + xOffset + c * xIncrement, idxAL3.position.y, idxAL3.position.z - zOffset - c * zIncrement);
   stlModel4.scale.set(0.35, 0.35, SA4);
  }

  //增加模型
  function addModel(_objCollect, labelData, geometry, c,
   position, rotation, center, scale, color,
   xOffset = 0, xIncrement = 0, zOffset = 0, zIncrement = 0) {
   const loader = new STLLoader();
   var material = new THREE.MeshPhongMaterial({ color: color });
   var stlModel = new THREE.Mesh(geometry, material);
   stlModel.obj_name = name;
   stlModel.obj_type = 'plane';
   if (labelData) stlModel.label = labelData[c];
   scene.add(stlModel);
   if (center) {
    stlModel.rotation.set(
     rotation._x,
     rotation._y,
     rotation._z
    );
    var newPos = rotatePoint(position.x + xOffset + c * xIncrement, position.y, position.z - zOffset - c * zIncrement,
     center.x, center.y, center.z,
     rotation._x * 180 / Math.PI, rotation._y * 180 / Math.PI, rotation._z * 180 / Math.PI)

    stlModel.position.set(newPos.x, newPos.y, newPos.z);
   }
   else {
    stlModel.rotation.set(
     rotation._x,
     rotation._y,
     rotation._z
    );
    stlModel.position.set(position.x + xOffset + c * xIncrement, position.y, position.z - zOffset - c * zIncrement);
   }

   stlModel.scale.set(scale.x, scale.y, scale.z);

   _objCollect[c].push(stlModel);
  }

  function setBridgeCamera(no) {
   if (!no) no = labelInfo.gateClick;
   let sumX = 0, sumY = 0, sumZ = 0;
   let count = 0;

   scene.traverse(function (object) {
    if (object.isMesh && object.label && object.label == no) {
     sumX += object.position.x;
     sumY += object.position.y;
     sumZ += object.position.z;
     count++;
    }
   });

   const centerX = sumX / count;
   const centerY = sumY / count;
   const centerZ = sumZ / count;
   // 设置摄像机看向新的中心点

   // 设置摄像机位置
   const cameraDistance = 50; // 摄像机与目标点的距离
   const cameraHeight = 50; // 摄像机的高度
   camera.position.set(centerX, centerY + cameraHeight, centerZ);

   // 计算摄像机指向目标点的方向向量
   const direction = new THREE.Vector3(centerX, centerY, centerZ).sub(camera.position).normalize();

   // 设置摄像机的方向
   camera.lookAt(new THREE.Vector3(centerX, centerY, centerZ));
   camera.up.set(0, 1, 0); // 设置摄像机的上方向为正上方

   // 将摄像机方向旋转90度
   camera.rotateX(-Math.PI / 2);

   // 更新控制器的目标点到摄像机所在位置的正上方
   controls.target.set(centerX, 0, centerZ);

   // 更新摄像机的投影矩阵
   camera.updateProjectionMatrix();

  }


  function setLabelData(id, data) {
   document.getElementById(id).innerHTML = data;
  }

  function setLabelDataColor(id, data) {
   document.getElementById(id).style.backgroundColor = data;
  }

  function setLabelVisible(id, data) {
   document.getElementById(id).style.visibility = data ? 'hidden' : 'visible';
  }

  function setPlaneData(no, data) {
   document.getElementById(no + "_plane").innerHTML = data;
  }

  function setPlaneDataColor(no, data) {
   document.getElementById(no + "_plane").style.backgroundColor = data;
  }

  function setWindData(no, data) {
   document.getElementById(no + "_wind").innerText = data;
  }

  function setWindDataColor(no, data) {
   document.getElementById(no + "_wind").style.backgroundColor = data;
  }
  function clearLabelFlash(id) {
   document.getElementById(id).style.visibility = 'visible';
   if (_collect_intervalId[`id_${id}`]) {
    clearInterval(_collect_intervalId[`id_${id}`]);
    _collect_intervalId[`id_${id}`] = false;
   }
  }

  function setLabelFlash(id) {
   if (_collect_intervalId[`id_${id}`]) return;
   document.getElementById(id).style.visibility = document.getElementById(id).style.visibility == 'hidden' ? 'visible' : 'hidden';
  }

  function clearFlash(no, b, i) {
   setVisible(no, b, i, false, false);
   if (_collect_intervalId[`${no}_${b}_${i}`]) {
    clearInterval(_collect_intervalId[`${no}_${b}_${i}`]);
    _collect_intervalId[`${no}_${b}_${i}`] = false;
   }
  }

  function setFlash(no, b, i) {
   if (_collect_intervalId[`${no}_${b}_${i}`]) return;
   _collect_intervalId[`${no}_${b}_${i}`] = setInterval(function (no, b, i) {
    setVisible(no, b, i, null, true);
   }, 500, no, b, i); // 设置闪烁间隔（毫秒）
  }


  function setVisible(no, b, i, isHidden, reverse) {
   const _bridges = [bridge1, bridge2, bridge3];
   const _bridgeCodes = [bridge_code1, bridge_code2, bridge_code3];

   for (let j = 0; j < _bridgeCodes.length; j++) {
    const _index = _bridgeCodes[j].findIndex(x => x == no);
    if (_index > -1) {
     const _bridge = _bridges[j];
     const _types = ['L', 'LA', 'LB', `AL${i}`, `BL${i}`];
     for (let k = 0; k < _types.length; k++) {
      const _type = _types[k];
      let p;
      if (b == null && i == null) {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      } else if (b != null && b.indexOf("_A") > -1 && i == null && _type == 'LA') {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      } else if (b != null && b.indexOf("_B") > -1 && i == null && _type == 'LB') {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      } else if (b != null && b.indexOf("_A") > -1 && i != null && _type == `AL${i}`) {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      } else if (b != null && b.indexOf("_B") > -1 && i != null && _type == `BL${i}`) {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      }
      if (p > -1) {
       if (reverse) {
        isHidden = !_bridge[_index][p].material.transparent;
       }

       if (isHidden) {
        _bridge[_index][p].material.transparent = true;
        _bridge[_index][p].material.opacity = 0;
       }
       else {
        _bridge[_index][p].material.transparent = false;
        _bridge[_index][p].material.opacity = 1;
       }
       break;

      }
     }
     break;
    }
   }
  }



  function setColor(no, b, i, c) {

   const _bridges = [bridge1, bridge2, bridge3];
   const _bridgeCodes = [bridge_code1, bridge_code2, bridge_code3];

   for (let j = 0; j < _bridgeCodes.length; j++) {
    const _index = _bridgeCodes[j].findIndex(x => x == no);
    if (_index > -1) {
     const _bridge = _bridges[j];
     const _types = ['L', 'LA', 'LB', `AL${i}`, `BL${i}`];
     for (let k = 0; k < _types.length; k++) {
      const _type = _types[k];
      let p;
      if (b == null && i == null) {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      } else if (b != null && b.indexOf("_A") > -1 && i == null && _type == 'LA') {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      } else if (b != null && b.indexOf("_B") > -1 && i == null && _type == 'LB') {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      } else if (b != null && b.indexOf("_A") > -1 && i != null && _type == `AL${i}`) {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      } else if (b != null && b.indexOf("_B") > -1 && i != null && _type == `BL${i}`) {
       p = _bridge[_index].findIndex(x => x.obj_type == _type);
      }
      if (p > -1) {
       _bridge[_index][p].material.color.set(c);
       break;

      }
     }
     break;
    }
   }
  }

  //載入模型
  function loadModels(promises, _objCollect, labelData, tmpData, xOffset = 0, xIncrement = 0, zOffset = 0, zIncrement = 0, reflectivity = 1, emissive = '#000000', transparent = false, opacity = 1) {

   for (let c = 0; c < _objCollect.length; c++) {
    tmpData.forEach((item, i) => {
     const promise = new Promise((resolve, reject) => {
      if (item.name.indexOf('.stl') > -1) {
       const loader = new STLLoader();
       loader.load(item.name, function (geometry) {
        if (xOffset == -100000)  //飛機
        {
         _objCollect[c] = geometry;
         resolve();
         return;
        }

        var material = new THREE.MeshPhongMaterial({ color: item.color, reflectivity: reflectivity, emissive: emissive });
        var stlModel = new THREE.Mesh(geometry, material);
        stlModel.obj_name = item.name;
        if (item.obj_type != '') stlModel.obj_type = item.obj_type;
        if (labelData) stlModel.label = labelData[c];
        scene.add(stlModel);
        // 設置模型位置、縮放和旋轉

        if (item.center) {
         stlModel.rotation.set(
          item.rotation._x,
          item.rotation._y,
          item.rotation._z
         );
         var newPos = rotatePoint(item.position.x, item.position.y, item.position.z,
          item.center.x, item.center.y, item.center.z,
          item.rotation._x * 180 / Math.PI, item.rotation._y * 180 / Math.PI, item.rotation._z * 180 / Math.PI)

         // 在这个闭包内，i和item是被正确捕获的
         stlModel.position.set(newPos.x + xOffset + c * xIncrement, newPos.y, newPos.z - zOffset - c * zIncrement);
        }
        else {

         stlModel.rotation.set(
          item.rotation._x,
          item.rotation._y,
          item.rotation._z
         );
         // 在这个闭包内，i和item是被正确捕获的
         stlModel.position.set(item.position.x + xOffset + c * xIncrement, item.position.y, item.position.z - zOffset - c * zIncrement);
        }

        stlModel.scale.set(item.scale.x, item.scale.y, item.scale.z);

        _objCollect[c].push(stlModel);


        if (item.obj_type.indexOf('label') > -1 && labelData) {


         const _Div = document.createElement("div");
         _Div.id = labelData[c];
         _Div.style.padding = '3px';
         _Div.style.color = '#fff';
         _Div.style.fontSize = '12px';
         _Div.style.position = 'absolute';
         _Div.style.backgroundColor = 'rgba(25,25,25,0.5)';
         _Div.style.borderRadius = '3px';
         _Div.className = "label";
         _Div.textContent = labelData[c];
         _Div.style.marginTop = "-1em";
         if (labelData) _Div.label = labelData[c];

         _Div.addEventListener('mouseover', function () {
          // 滑鼠移到登機門圖示錨點
          // _Div.style.background = 'lightblue'; // 鼠标悬停时改变背景颜色
          labelInfo.gateMouseover = labelData[c]; // 更新 GUI 显示的标签信息
          gui.updateDisplay(); // 更新 GUI 显示
         });
         _Div.addEventListener('mouseout', function (e) {
          //_Div.style.background = 'rgba(25,25,25,0.5)'; // 鼠标离开时恢复背景颜色
         });
         const _Label = new CSS2DObject(_Div);
         _Label.position.set(-3, 20, 10);
         stlModel.add(_Label);



         const _Div2 = document.createElement("div");
         _Div2.id = labelData[c] + "_wind";
         _Div2.style.padding = '3px';
         _Div2.style.color = '#fff';
         _Div2.style.fontSize = '12px';
         _Div2.style.position = 'absolute';
         _Div2.style.backgroundColor = 'rgba(25,25,25,0.5)';
         _Div2.style.borderRadius = '3px';
         _Div2.className = "label wind";
         _Div2.textContent = "10 / 20";
         _Div2.style.marginTop = "-1em";
         if (labelData) _Div2.label = labelData[c];


         const _Label2 = new CSS2DObject(_Div2);
         _Label2.position.set(3, 20, 10);
         stlModel.add(_Label2);


         const _Div3 = document.createElement("div");
         _Div3.id = labelData[c] + "_plane";
         _Div3.style.padding = '3px';
         _Div3.style.color = '#fff';
         _Div3.style.fontSize = '12px';
         _Div3.style.position = 'absolute';
         _Div3.style.backgroundColor = 'rgba(25,25,25,0.5)';
         _Div3.style.borderRadius = '3px';
         _Div3.className = "label plane";
         _Div3.innerHTML = "C000  1234<br>抵達時間<br>離開時間";
         _Div3.style.marginTop = "-1em";
         if (labelData) _Div3.label = labelData[c];


         const _Label3 = new CSS2DObject(_Div3);
         _Label3.position.set(10, 20, 10);
         stlModel.add(_Label3);


         const _Div4 = document.createElement("div");
         _Div4.style.padding = '3px';
         _Div4.style.display = 'none';
         _Div4.className = "label fire";
         _Div4.innerHTML = '<img src=fire.gif class=fire />'
         if (labelData) _Div4.label = labelData[c];


         const _Label4 = new CSS2DObject(_Div4);
         _Label4.position.set(10, 20, 10);
         stlModel.add(_Label4);
        }

        resolve();
       });
      }
      else if (item.name.indexOf('light') > -1) {
       const pointLight = new THREE.PointLight(item.color, 1, 50); // 紅色光源
       pointLight.position.set(item.position.x + xOffset + c * xIncrement, item.position.y, item.position.z - zOffset - c * zIncrement); // 設定光源位置
       pointLight.obj_name = item.name;
       if (labelData) pointLight.label = labelData[c];
       scene.add(pointLight);
       _objCollect[c].push(pointLight);

       resolve();
      }
      else if (item.name.indexOf('sphere') > -1) {
       const sphereSize = 0.1;
       const bulbGeometry = new THREE.SphereGeometry(sphereSize, 16, 8);
       const bulbMaterial = new THREE.MeshBasicMaterial({ color: item.color }); // 與光源顏色相同
       const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
       bulb.position.set(item.position.x + xOffset + c * xIncrement, item.position.y, item.position.z - zOffset - c * zIncrement);  // 設置與光源相同的位置
       bulb.obj_name = item.name;
       if (item.obj_type != '') bulb.obj_type = item.obj_type;
       if (labelData) bulb.label = labelData[c];
       scene.add(bulb);
       _objCollect[c].push(bulb);


       if ((item.obj_type == "AL1" || item.obj_type == "BL1" || item.obj_type == "CL1") && labelData) {
        const _Div = document.createElement("div");
        _Div.id = labelData[c] + "_" + item.obj_type.replace("L1", "");
        _Div.style.padding = '3px';
        _Div.style.color = '#fff';
        _Div.style.fontSize = '12px';
        _Div.style.position = 'absolute';
        _Div.style.backgroundColor = 'rgba(25,25,25,0.5)';
        _Div.style.borderRadius = '3px';
        _Div.className = "label bridge";
        _Div.textContent = labelData[c] + "_" + item.obj_type.replace("L1", "");
        _Div.style.marginTop = "-1em";
        if (labelData) _Div.label = labelData[c];

        _Div.addEventListener('mouseover', function () {
         // 滑鼠移到登機門圖示錨點
         // _Div.style.background = 'lightblue'; // 鼠标悬停时改变背景颜色
         labelInfo.bridgeMouseover = labelData[c] + "_" + item.obj_type.replace("L1", ""); // 更新 GUI 显示的标签信息
         gui.updateDisplay(); // 更新 GUI 显示
        });
        _Div.addEventListener('mouseout', function (e) {
         //_Div.style.background = 'rgba(25,25,25,0.5)'; // 鼠标离开时恢复背景颜色
        });
        const _Label = new CSS2DObject(_Div);
        _Label.position.set(0, 0, 0);
        bulb.add(_Label);


       }

       if (item.obj_type == "AL1" || item.obj_type == "AL2" || item.obj_type == "AL3" ||
        item.obj_type == "BL1" || item.obj_type == "BL2" || item.obj_type == "BL3" ||
        item.obj_type == "CL1" || item.obj_type == "CL2" || item.obj_type == "CL3") {

        const _Div1 = document.createElement("div");
        _Div1.id = labelData[c] + "_" + item.obj_type + "_fire";
        _Div1.style.padding = '3px';
        _Div1.className = "label fire";
        _Div1.innerHTML = '<img src=fire.gif class=fire />'
        if (labelData) _Div1.label = labelData[c];
        const _Label1 = new CSS2DObject(_Div1);
        _Label1.position.set(0, 0, 0);
        bulb.add(_Label1);
       }
       resolve();
      }

     });
     promises.push(promise);
    });
   }
  }

  function onMouseDown(event) {
   // 计算鼠标在场景中的位置 
   mouse.x = (event.clientX / container.offsetWidth) * 2 - 1;
   mouse.y = -(event.clientY / container.offsetHeight) * 2 + 1;

   // 更新raycaster的射线方向
   raycaster.setFromCamera(mouse, camera);

   // 计算物体和射线的交点
   const intersects = raycaster.intersectObjects(scene.children);

   if (intersects.length > 0) {
    // 如果有物体被选中 
    var idx = intersects.findIndex(x => x.object.label);
    if (idx > -1) {
     labelInfo.modelClick = intersects[idx].object.label;
     gui.updateDisplay(); // 更新 GUI 显示

    }
   }
  }

  function onMouseDblClick(event) {
   var bridge = null;
   var gate = null;
   if (labelInfo.gateMouseover && labelInfo.gateMouseover != 'None') labelInfo.gateDblClick = labelInfo.gateMouseover;
   if (labelInfo.bridgeMouseover && labelInfo.bridgeMouseover != 'None') labelInfo.bridgeDblClick = labelInfo.bridgeMouseover;

   // 计算鼠标在场景中的位置 
   mouse.x = (event.clientX / container.offsetWidth) * 2 - 1;
   mouse.y = -(event.clientY / container.offsetHeight) * 2 + 1;

   // 更新raycaster的射线方向
   raycaster.setFromCamera(mouse, camera);

   // 计算物体和射线的交点
   const intersects = raycaster.intersectObjects(scene.children);

   if (intersects.length > 0) {
    intersects.forEach(element => {
     if (element.object.label) {
      if (gate == null) gate = intersects[0].object.label;
      labelInfo.gateDblClick = intersects[0].object.label;
     }
     if (element.object.obj_type) {
      if (bridge == null) bridge = element.object.obj_type;
      if (element.object.obj_type == "A1" || element.object.obj_type == "A2" || element.object.obj_type == "A3")
       labelInfo.bridgeDblClick = element.object.label + "_A";
      if (element.object.obj_type == "B1" || element.object.obj_type == "B2" || element.object.obj_type == "B3")
       labelInfo.bridgeDblClick = element.object.label + "_B";
      if (element.object.obj_type == "C1" || element.object.obj_type == "C2" || element.object.obj_type == "C3")
       labelInfo.bridgeDblClick = element.object.label + "_C";
      if (element.object.obj_type == "label")
       labelInfo.gateDblClick = element.object.label;
     }
     gui.updateDisplay(); // 更新 GUI 显示
    });
    // 如果有物体被选中 

    gui_bridge.domElement.style.display = 'block';
    gui.domElement.style.display = 'none';
    bimModel.style.visibility = 'hidden';
    bimModel_bridge.style.visibility = 'visible';
    // 使用者在空橋標籤或空橋錨點雙擊滑鼠，BIM Model 切換至空橋細部 
    enterBridgeId = labelInfo.bridgeDblClick;
    ap_didEnterBridgeScene(labelInfo.bridgeDblClick);
   }
  }

  function onMouseClick(event) {
   var gate = null;
   var bridge = null;
   if (labelInfo.gateMouseover && labelInfo.gateMouseover != 'None') labelInfo.gateClick = labelInfo.gateMouseover;
   if (labelInfo.bridgeMouseover && labelInfo.bridgeMouseover != 'None') labelInfo.bridgeClick = labelInfo.bridgeMouseover;
   // 如果是2d

   // 计算鼠标在场景中的位置 
   mouse.x = (event.clientX / container.offsetWidth) * 2 - 1;
   mouse.y = -(event.clientY / container.offsetHeight) * 2 + 1;

   // 更新raycaster的射线方向
   raycaster.setFromCamera(mouse, camera);

   // 计算物体和射线的交点
   const intersects = raycaster.intersectObjects(scene.children);

   if (intersects.length > 0) {
    // 如果有物体被选中 
    intersects.forEach(element => {
     if (element.object.label) {
      if (gate == null) gate = intersects[0].object.label;
      labelInfo.gateClick = intersects[0].object.label;
     }
     if (element.object.obj_type) {
      if (bridge == null) bridge = element.object.obj_type;
      if (element.object.obj_type == "A1" || element.object.obj_type == "A2" || element.object.obj_type == "A3" || element.object.obj_type == "A4")
       labelInfo.bridgeClick = element.object.label + "_A";
      if (element.object.obj_type == "B1" || element.object.obj_type == "B2" || element.object.obj_type == "B3" || element.object.obj_type == "B4")
       labelInfo.bridgeClick = element.object.label + "_B";
      if (element.object.obj_type == "C1" || element.object.obj_type == "C2" || element.object.obj_type == "C3" || element.object.obj_type == "C4")
       labelInfo.bridgeClick = element.object.label + "_C";
      if (element.object.obj_type == "label")
       labelInfo.gateClick = element.object.label;
     }
     gui.updateDisplay(); // 更新 GUI 显示
    });
    if (gate != null && bridge != null) {
     if (bridge == "A1") ap_showBridgeDetailInfo(gate + "_A", 0);
     if (bridge == "A2") ap_showBridgeDetailInfo(gate + "_A", 0);
     if (bridge == "A3") ap_showBridgeDetailInfo(gate + "_A", 1);
     if (bridge == "A4") ap_showBridgeDetailInfo(gate + "_A", 2);
     if (bridge == "B1") ap_showBridgeDetailInfo(gate + "_B", 0);
     if (bridge == "B2") ap_showBridgeDetailInfo(gate + "_B", 0);
     if (bridge == "B3") ap_showBridgeDetailInfo(gate + "_B", 1);
     if (bridge == "B4") ap_showBridgeDetailInfo(gate + "_B", 2);
    } else if (bridge != null) {
     ap_showBridgeInfo(bridge)
    }
   }
  }

  function onMouseMove(event) {
   // 计算鼠标在场景中的位置 
   mouse.x = (event.clientX / container.offsetWidth) * 2 - 1;
   mouse.y = -(event.clientY / container.offsetHeight) * 2 + 1;

   // 更新raycaster的射线方向
   raycaster.setFromCamera(mouse, camera);

   // 计算物体和射线的交点
   const intersects = raycaster.intersectObjects(scene.children);

   var oldGateMouseover = labelInfo.gateMouseover;
   if (intersects.length > 0) {
    intersects.forEach(element => {
     if (element.object.label) labelInfo.gateMouseover = element.object.label;
     if (element.object.obj_type) {
      if (element.object.obj_type == "A1" || element.object.obj_type == "A2" || element.object.obj_type == "A3" || element.object.obj_type == "A4")
       labelInfo.bridgeMouseover = element.object.label + "_A";
      if (element.object.obj_type == "B1" || element.object.obj_type == "B2" || element.object.obj_type == "B3" || element.object.obj_type == "B4")
       labelInfo.bridgeMouseover = element.object.label + "_B";
      if (element.object.obj_type == "C1" || element.object.obj_type == "C2" || element.object.obj_type == "C3" || element.object.obj_type == "C4")
       labelInfo.bridgeMouseover = element.object.label + "_C";
      if (element.object.obj_type == "label")
       labelInfo.gateMouseover = element.object.label;
     }
    });
    gui.updateDisplay(); // 更新 GUI 显示
    // axesHelper.position.copy(intersects[0].point);
   }
   if (oldGateMouseover != labelInfo.gateMouseover) {
    var els = document.getElementsByClassName("plane");
    for (var i = 0; i < els.length; i++) {
     if (els[i].label == labelInfo.gateMouseover)
      els[i].style.display = 'block';
     else
      els[i].style.display = 'none';
    };
    oldGateMouseover = labelInfo.gateMouseover;
    brideMouseOVer(oldGateMouseover);
   }
  }


  function backOrverAll() {
   gui_bridge.domElement.style.display = 'none';
   gui.domElement.style.display = 'block';
   bimModel.style.visibility = 'visible';
   bimModel_bridge.style.visibility = 'hidden';
   resetCameraAndControls();
   ap_didLeaveBridgeScene(enterBridgeId);
  }

  function loadAllModels() {
   const promises = [];



   loadModels(promises, bridge1, bridge_code1, bridgeData1, 20, 0, -20, 10);
   loadModels(promises, bridge2, bridge_code2, bridgeData2, -25, 0, -20, 10);
   loadModels(promises, bridge3, bridge_code3, bridgeData3, -12, 5, -23, 0);
   loadModels(promises, [[]], null, mainBuilding, 0, 0, 0, 0, 0.1, '#333333');
   loadModels(promises, _objPlaneCollect, null, planeData, -100000); // -100000 不顯示


   Promise.all(promises).then(() => {
    clearAllplane();
    ap_didLaunchView();
    var els = document.getElementsByClassName("label plane");
    for (var i = 0; i < els.length; i++) {
     els[i].style.visibility = "hidden"
    };
    var elsf = document.getElementsByClassName("label fire");
    for (var i = 0; i < elsf.length; i++) {
     elsf[i].style.visibility = "hidden"
    };
    console.log("All models have been loaded:",);

   }).catch(error => {
    console.error("Error loading models:", error);
   });
  }

  function init() {
   // Scene setup
   scene = new THREE.Scene();
   // 添加天空背景
   scene.background = new THREE.Color('skyblue');
   // 添加地面
   var planeGeometry = new THREE.PlaneGeometry(10000, 10000); // 創建一個平面幾何體，寬和長均為10000
   var planeMaterial = new THREE.MeshLambertMaterial({ color: 0xc0f8b1 }); // 為平面創建材質，設定顏色為淺綠色
   var plane = new THREE.Mesh(planeGeometry, planeMaterial); // 使用幾何體和材質創建Mesh
   plane.rotation.x = -Math.PI / 2; // 將平面旋轉為水平，面向上方
   plane.position.y = -1; // 將地面位置稍微下降，避免與模型重疊
   scene.add(plane); // 將平面添加到場景中

   // 創建相機
   camera = new THREE.PerspectiveCamera(C.fov, container.offsetWidth / container.offsetHeight, C.near, C.far); // 使用配置參數創建透視相機
   camera.position.set(C.position.x, C.position.y, C.position.z); // 設定相機位置
   camera.rotation.set(C.rotation._x, C.rotation._y, C.rotation._z); // 設定相機旋轉
   camera.quaternion.set(C.quaternion._x, C.quaternion._y, C.quaternion._z, C.quaternion._w); // 設定相機四元數，用於控制旋轉
   camera.zoom = C.zoom; // 設定相機的縮放級別
   camera.updateProjectionMatrix(); // 更新相機的投影矩陣

   // 初始化渲染器
   renderer = new THREE.WebGLRenderer(); // 創建WebGL渲染器
   renderer.setSize(container.offsetWidth, container.offsetHeight);
   container.appendChild(renderer.domElement); // 將渲染器的DOM元素掛載到HTML中的指定元素上

   labelRenderer = new CSS2DRenderer();
   labelRenderer.setSize(container.offsetWidth, container.offsetHeight);
   labelRenderer.domElement.style.position = "absolute";
   labelRenderer.domElement.style.top = "0px";
   container.appendChild(labelRenderer.domElement);
   // 添加照明
   light = new THREE.DirectionalLight(0x888888, 1); // 創建一個白色的方向光源
   light.position.set(1, 100, 1).normalize(); // 設定光源的位置並正規化
   scene.add(light); // 將光源添加到場景中


   axesHelper = new THREE.AxesHelper(5);
   //scene.add(axesHelper);


   // 實例化OrbitControls，允許用戶通過拖動來旋轉視角，滾動來縮放
   controls = new OrbitControls(camera, labelRenderer.domElement);
   controls.enableDamping = true; // 啟用阻尼效果，使交互更加平滑
   controls.dampingFactor = 0.25; // 設定阻尼系數
   controls.screenSpacePanning = false; // 禁用屏幕空間平移
   controls.target.set(C.target.x, C.target.y, C.target.z); // 設定控制的目標點
   controls.update(); // 更新控制器的內部狀態

   // 设置最小极角为0，防止低于地平面
   // Math.PI / 2 是90度，意味着视线平行于地面，不允许更低
   controls.minPolarAngle = 0; // 不允许移动到地面以下
   controls.maxPolarAngle = Math.PI / 2; // 最大旋转角度
   for (var c = 0; c < 8; c++)
    bridge1.push([]);
   for (var c = 0; c < 8; c++)
    bridge2.push([]);
   for (var c = 0; c < 5; c++)
    bridge3.push([]);
   // Handle STL upload 

   // 呼叫 loadModels 函數來加載和顯示所有模型
   loadAllModels();


   var material = new THREE.LineBasicMaterial({ color: 0xffffff });
   var material1 = new THREE.LineBasicMaterial({ color: 0xffff00 });

   for (var c = 0; c < 8; c++) {// 半圓弧的參數
    var xOffset = 20, xIncrement = 0, zOffset = -25, zIncrement = 10;
    var cX = 17.5 + xOffset + c * xIncrement; // 設置中心點X坐標（正方形的中心點）
    var cY = 1;                               // 半圓弧在Y軸上的高度，與正方形相同
    var cZ = 27.5 - c * zIncrement;             // 設置中心點Z坐標（正方形底邊的中點）
    var radius = 2.5;                              // 半圓弧的半徑
    var startAngle = 0;                  // 起始角度，Math.PI/2 代表90度
    var endAngle = -Math.PI / 2;                   // 終止角度，-Math.PI/2 代表-90度
    var segments = 32;                             // 半圓弧的分段數，增加此數值可使弧更平滑

    var pointsA = [];

    for (var i = 60; i > 27.5 - c * zIncrement; i--) {
     pointsA.push(new THREE.Vector3(40, 1, i));
    }

    for (var i = 0; i <= segments; i++) {
     var theta = startAngle + (endAngle - startAngle) * (i / segments);
     var x = cX + radius * Math.cos(theta);
     var z = cZ + radius * Math.sin(theta); x
     pointsA.push(new THREE.Vector3(x, cY, z));
    }

    for (var i = 17.5; i > 5; i -= 0.5) {
     pointsA.push(new THREE.Vector3(i + xOffset + c * xIncrement, 1, - zOffset - c * zIncrement));
    }
    var geometryA = new THREE.BufferGeometry().setFromPoints(pointsA);
    var lineA = new THREE.Line(geometryA, material1);
    scene.add(lineA);
   }


   for (var c = 0; c < 8; c++) {// 半圓弧的參數
    var xOffset = -25, xIncrement = 0, zOffset = -25, zIncrement = 10;
    var cX = -37.5 - c * xIncrement; // 設置中心點X坐標（正方形的中心點）
    var cY = 1;                               // 半圓弧在Y軸上的高度，與正方形相同
    var cZ = 22.5 - c * zIncrement;             // 設置中心點Z坐標（正方形底邊的中點）
    var radius = 2.5;                              // 半圓弧的半徑
    var startAngle = Math.PI;                  // 起始角度，Math.PI/2 代表90度
    var endAngle = Math.PI / 2;                   // 終止角度，-Math.PI/2 代表-90度
    var segments = 32;                             // 半圓弧的分段數，增加此數值可使弧更平滑
    var pointsA = [];

    for (var i = -90; i < 22.5 - c * zIncrement; i++) {
     pointsA.push(new THREE.Vector3(-40, 1, i));
     console.log('l', c, -40, 1, i)
    }
    for (var i = 0; i <= segments; i++) {
     var theta = startAngle + (endAngle - startAngle) * (i / segments);
     var x = cX + radius * Math.cos(theta);
     var z = cZ + radius * Math.sin(theta);
     pointsA.push(new THREE.Vector3(x, cY, z));
    }

    for (var i = -37.5; i < -26.5; i += 0.5) {
     pointsA.push(new THREE.Vector3(i + c * xIncrement, 1, - zOffset - c * zIncrement));
    }

    // 創建幾何體並將點陣列設置進去
    var geometryA = new THREE.BufferGeometry().setFromPoints(pointsA);

    // 創建線條
    var lineA = new THREE.Line(geometryA, material1);

    // 將線條添加到場景中（假設你已經有一個名為scene的THREE.Scene對象）
    scene.add(lineA);
   }



   for (var c = 0; c < 5; c++) {
    // -12, 5, -23, 0
    var xOffset = -12, xIncrement = 5, zOffset = -23, zIncrement = 0;
    var cX = -11 + c * xIncrement; // 設置中心點X坐標（正方形的中心點）
    var cY = 1;                               // 半圓弧在Y軸上的高度，與正方形相同
    var cZ = 37.5 - c * zIncrement;             // 設置中心點Z坐標（正方形底邊的中點）
    var radius = 2.5;                              // 半圓弧的半徑
    var startAngle = Math.PI / 2;                  // 起始角度，Math.PI/2 代表90度
    var endAngle = 0;                   // 終止角度，-Math.PI/2 代表-90度
    var segments = 32;                             // 半圓弧的分段數，增加此數值可使弧更平滑


    var pointsA = [];
    for (var i = -55; i < -10 + c * xIncrement; i++)
     pointsA.push(new THREE.Vector3(i, 1, 40));
    for (var i = 0; i <= segments; i++) {
     var theta = startAngle + (endAngle - startAngle) * (i / segments);
     var x = cX + radius * Math.cos(theta);
     var z = cZ + radius * Math.sin(theta);
     pointsA.push(new THREE.Vector3(x, cY, z));
     console.log('a', x, cY, z)
    }

    for (var i = 36; i > 25; i -= 0.5) {
     pointsA.push(new THREE.Vector3(-8.5 + c * xIncrement, 1, i));
     console.log('l', -8.5 + c * xIncrement, 1, i)
    }


    var geometryA = new THREE.BufferGeometry().setFromPoints(pointsA);
    var lineA = new THREE.Line(geometryA, material1);
    scene.add(lineA);
   }


   let sumX = 0, sumY = 0, sumZ = 0;
   let count = 0;

   // 计算所有对象的坐标平均值
   scene.traverse(function (object) {
    if (object.isMesh) {
     sumX += object.position.x;
     sumY += object.position.y;
     sumZ += object.position.z;
     count++;
    }
   });

   const centerX = sumX / count;
   const centerY = sumY / count;
   const centerZ = sumZ / count;

   // 设置摄像机看向新的中心点
   camera.lookAt(centerX, centerY, centerZ);
   camera.updateProjectionMatrix();

   // Raycaster和鼠标位置
   raycaster = new THREE.Raycaster();
   mouse = new THREE.Vector2();

   // 滑鼠事件
   container.addEventListener('mousedown', onMouseDown, false);
   container.addEventListener('click', onMouseClick, false);
   container.addEventListener('dblclick', onMouseDblClick, false);
   container.addEventListener('mousemove', onMouseMove, false);

   var cameraFolder = gui.addFolder('Camera');
   var camPosition = cameraFolder.addFolder('Position');
   var camRotation = cameraFolder.addFolder('Rotation');

   // 添加位置和旋转的控制
   camPosX = camPosition.add(camera.position, 'x', -500, 500);
   camPosY = camPosition.add(camera.position, 'y', -500, 500);
   camPosZ = camPosition.add(camera.position, 'z', -500, 500);

   camRotX = camRotation.add(camera.rotation, 'x', -Math.PI, Math.PI);
   camRotY = camRotation.add(camera.rotation, 'y', -Math.PI, Math.PI);
   camRotZ = camRotation.add(camera.rotation, 'z', -Math.PI, Math.PI);


   // 添加OrbitControls的目标点控制
   var controlsFolder = gui.addFolder('OrbitControls Target');
   controlTargetX = controlsFolder.add(controls.target, 'x', -1000, 1000);
   controlTargetY = controlsFolder.add(controls.target, 'y', -1000, 1000);
   controlTargetZ = controlsFolder.add(controls.target, 'z', -1000, 1000);
   cameraFolder.add({ setBridgeCamera }, 'setBridgeCamera').name('setBridgeCamera');
   cameraFolder.add({ resetCameraAndControls }, 'resetCameraAndControls').name('Reset Camera');
   var camMouse = gui.addFolder('Mouse');
   camMouse.add(labelInfo, 'gateClick').name('gateClick');
   camMouse.add(labelInfo, 'gateDblClick').name('gateDblClick');
   camMouse.add(labelInfo, 'gateMouseover').name('gateMouseover');
   camMouse.add(labelInfo, 'bridgeClick').name('bridgeClick');
   camMouse.add(labelInfo, 'bridgeDblClick').name('bridgeDblClick');
   camMouse.add(labelInfo, 'bridgeMouseover').name('bridgeMouseover');
   camMouse.add(labelInfo, 'modelClick').name('modelClick');
   var camPlane = gui.addFolder('Plane');
   var modelController = camPlane.add(planeModels, 'selectedModel', allModels).name('Aircraft Models');
   modelController.onChange(function (value) {
    console.log("Selected Model: " + value);
    setPlane();
   });
   camPlane.add(planeXYA, 'x', -50, 50).name('planeX').onChange(function () {
    setPlaneXYA();

   });
   camPlane.add(planeXYA, 'y', -100, 100).name('planeY').onChange(function () {
    setPlaneXYA();

   });
   camPlane.add(planeXYA, 'a', 0, 360).name('planeY').onChange(function () {
    setPlaneXYA();

   });
   camPlane.add({ clearAllplane }, 'clearAllplane').name('Clear All Plane');


   var bridgeAngle = gui.addFolder('bridgeAngle');
   bridgeAngle.add(bridgeAngles, 'rotationA2', -360, 360).name('A2').onChange(function (angle) {
    setBridgeAngle('A');

   });
   bridgeAngle.add(bridgeAngles, 'rotationA3', -90, 90).name('A3').onChange(function (angle) {
    setBridgeAngle('A');

   });
   bridgeAngle.add(bridgeAngles, 'rotationAS2', 0, 2).name('AS2').onChange(function (angle) {
    setBridgeAngle('A');

   });
   bridgeAngle.add(bridgeAngles, 'rotationAS3', 0.3, 1).name('AS3').onChange(function (angle) {
    setBridgeAngle('A');

   });
   bridgeAngle.add(bridgeAngles, 'rotationB2', -360, 360).name('B2').onChange(function (angle) {
    setBridgeAngle('B');

   });
   bridgeAngle.add(bridgeAngles, 'rotationB3', -90, 90).name('B3').onChange(function (angle) {
    setBridgeAngle('B');

   });
   bridgeAngle.add(bridgeAngles, 'rotationBS2', 0, 2).name('BS2').onChange(function (angle) {
    setBridgeAngle('B');

   });
   bridgeAngle.add(bridgeAngles, 'rotationBS3', 0.3, 1).name('BS3').onChange(function (angle) {
    setBridgeAngle('B');

   });

   bridgeAngle.add(bridgeAngles, 'rotationC2', -360, 360).name('C2').onChange(function (angle) {
    setBridgeAngle('C');

   });
   bridgeAngle.add(bridgeAngles, 'rotationC3', -90, 90).name('C3').onChange(function (angle) {
    setBridgeAngle('C');

   });
   bridgeAngle.add(bridgeAngles, 'rotationCS2', 0, 2).name('CS2').onChange(function (angle) {
    setBridgeAngle('C');

   });
   bridgeAngle.add(bridgeAngles, 'rotationCS3', 0.3, 1).name('CS3').onChange(function (angle) {
    setBridgeAngle('C');

   });
   var bridge_data_folder = gui.addFolder('bridge_data');
   bridge_data_folder.add({ value: '' }, 'value').name('wind data').onChange(function (value) {
    setWindData(labelInfo.gateClick, value)
   });

   bridge_data_folder.add({ value: '' }, 'value').name('plane data').onChange(function (value) {
    setPlaneData(labelInfo.gateClick, value)
   });
   bridge_data_folder.add({ value: '' }, 'value').name('label color').onChange(function (value) {
    setLabelDataColor(labelInfo.gateClick, value)
   });
   bridge_data_folder.add({ value: '' }, 'value').name('wind color').onChange(function (value) {
    setWindDataColor(labelInfo.gateClick, value)
   });
   bridge_data_folder.add({ value: '' }, 'value').name('plane color').onChange(function (value) {
    setPlaneDataColor(labelInfo.gateClick, value)
   });


   // 监听控制器的改变事件
   controls.addEventListener('change', () => {

    camPosX.setValue(camera.position.x);
    camPosY.setValue(camera.position.y);
    camPosZ.setValue(camera.position.z);

    camRotX.setValue(camera.rotation.x);
    camRotY.setValue(camera.rotation.y);
    camRotZ.setValue(camera.rotation.z);

    controlTargetX.setValue(controls.target.x);
    controlTargetY.setValue(controls.target.y);
    controlTargetZ.setValue(controls.target.z);
   });



   document.getElementById('setOverallData').addEventListener('click', setOverallData);
   document.getElementById('setBridgeData').addEventListener('click', setBridgeData);

   animate();
  }
  function clearFlash_bridge(c) {
   if (_collect_intervalId_bridge[c]) {
    clearInterval(_collect_intervalId_bridge[c]);
    _collect_intervalId_bridge[c] = false;
    var i = _objCollect_bridge.findIndex(x => x.obj_type == c);
    _objCollect_bridge[i].material.opacity = 1; // 切换透明度
    _objCollect_bridge[i].material.transparent = false;
   }
  }

  function setFlash_bridge(c) {
   clearFlash_bridge(c);
   _collect_intervalId_bridge[c] = setInterval(function (c) {
    var i = _objCollect_bridge.findIndex(x => x.obj_type == c);
    _objCollect_bridge[i].material.transparent = true;
    _objCollect_bridge[i].material.opacity = (_objCollect_bridge[i].material.opacity === 1) ? 0 : 1; // 切换透明度
   }, 500, c); // 设置闪烁间隔（毫秒）
  }
  //載入模型
  function loadModels_bridge(tmpData) {
   tmpData.forEach((item, i) => {
    if (item.name.indexOf('.stl') > -1) {
     const loader = new STLLoader();
     loader.load(item.name, function (geometry) {
      var reflectivity = 0.1, emissive = '#333333', transparent = false, opacity = 1, color = item.color;
      if (item.obj_type == 'Jetway') { transparent = true, opacity = 0.95, emissive = '#666666', color = '#666666' }
      var material = new THREE.MeshPhongMaterial({ color: color, reflectivity: reflectivity, emissive: emissive, transparent: transparent, opacity: opacity });
      var stlModel = new THREE.Mesh(geometry, material);
      stlModel.obj_name = item.name;
      if (item.obj_type != '') stlModel.obj_type = item.obj_type;
      scene_bridge.add(stlModel);

      // 設置模型位置、縮放和旋轉

      stlModel.rotation.set(
       item.rotation._x,
       item.rotation._y,
       item.rotation._z
      );
      // 在这个闭包内，i和item是被正确捕获的
      stlModel.position.set(item.position.x, item.position.y, item.position.z);


      stlModel.scale.set(item.scale.x, item.scale.y, item.scale.z);

      _objCollect_bridge.push(stlModel);
     });
    }
    else if (item.name.indexOf('sphere') > -1) {
     const sphereSize = 0.3;
     const bulbGeometry = new THREE.SphereGeometry(sphereSize, 16, 8);
     const bulbMaterial = new THREE.MeshBasicMaterial({ color: item.color }); // 與光源顏色相同
     const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
     bulb.position.set(item.position.x, item.position.y, item.position.z);  // 設置與光源相同的位置
     bulb.obj_name = item.name;
     if (item.obj_type != '') bulb.obj_type = item.obj_type;
     scene_bridge.add(bulb);
     _objCollect_bridge.push(bulb);

     const _Div = document.createElement("div");
     _Div.style.padding = '2px';
     _Div.style.color = '#fff';
     _Div.style.fontSize = '10px';
     _Div.style.position = 'absolute';
     _Div.style.backgroundColor = 'rgba(25,25,25,0.5)';
     _Div.style.borderRadius = '5px';
     _Div.className = "label";
     _Div.textContent = item.obj_type;
     _Div.style.marginTop = '2px';

     _Div.addEventListener('mouseover', function () {

     });
     _Div.addEventListener('mouseout', function () {
     });
     const _Label = new CSS2DObject(_Div);
     _Label.position.set(0, 1, 0);
     bulb.add(_Label);

    }

   });

  }


  function onMouseDown_bridge(event) {
   // 计算鼠标在场景中的位置 
   mouse_bridge.x = (event.clientX / container_bridge.offsetWidth) * 2 - 1;
   mouse_bridge.y = -(event.clientY / container_bridge.offsetHeight) * 2 + 1;

   // 更新raycaster的射线方向
   raycaster_bridge.setFromCamera(mouse_bridge, camera_bridge);

   // 计算物体和射线的交点
   const intersects = raycaster_bridge.intersectObjects(scene_bridge.children);

   if (intersects.length > 0) {
    // 如果有物体被选中 
    var idx = intersects.findIndex(x => x.object.obj_type);
    if (idx > -1) {
     console.log(intersects[idx].object.obj_type);
    }
   }
  }

  function onMouseDblClick_bridge(event) {
   // 计算鼠标在场景中的位置 
   mouse_bridge.x = (event.clientX / container_bridge.offsetWidth) * 2 - 1;
   mouse_bridge.y = -(event.clientY / container_bridge.offsetHeight) * 2 + 1;

   // 更新raycaster的射线方向
   raycaster_bridge.setFromCamera(mouse_bridge, camera_bridge);

   // 计算物体和射线的交点
   const intersects = raycaster_bridge.intersectObjects(scene_bridge.children);

   if (intersects.length > 0) {
    var idx = intersects.findIndex(x => x.object.obj_type);
    if (idx > -1) {
     console.log(intersects[idx].object.obj_type);
    }

   }
  }

  function onMouseClick_bridge(event) {
   // 如果是2d

   // 计算鼠标在场景中的位置 
   mouse_bridge.x = (event.clientX / container_bridge.offsetWidth) * 2 - 1;
   mouse_bridge.y = -(event.clientY / container_bridge.offsetHeight) * 2 + 1;

   // 更新raycaster的射线方向
   raycaster_bridge.setFromCamera(mouse_bridge, camera_bridge);

   // 计算物体和射线的交点
   const intersects = raycaster_bridge.intersectObjects(scene_bridge.children);

   if (intersects.length > 0) {
    // 如果有物体被选中 
    var idx = intersects.findIndex(x => x.object.obj_type);
    if (idx > -1) {
     console.log(intersects[idx].object.obj_type);
    }
   }
  }

  function onMouseMove_bridge(event) {
   // 计算鼠标在场景中的位置 
   mouse_bridge.x = (event.clientX / container_bridge.offsetWidth) * 2 - 1;
   mouse_bridge.y = -(event.clientY / container_bridge.offsetHeight) * 2 + 1;

   // 更新raycaster的射线方向
   raycaster_bridge.setFromCamera(mouse_bridge, camera_bridge);

   // 计算物体和射线的交点
   const intersects = raycaster_bridge.intersectObjects(scene_bridge.children);

   if (intersects.length > 0) {
    intersects.forEach(element => {
    });
   }
  }



  function init_bridge() {
   // Scene setup
   scene_bridge = new THREE.Scene();
   // 添加天空背景
   scene_bridge.background = new THREE.Color('skyblue');
   // 添加地面
   var planeGeometry = new THREE.PlaneGeometry(1000, 1000); // 創建一個平面幾何體，寬和長均為10000
   var planeMaterial = new THREE.MeshLambertMaterial({ color: 0xc0f8b1 }); // 為平面創建材質，設定顏色為淺綠色
   var plane_bridge = new THREE.Mesh(planeGeometry, planeMaterial); // 使用幾何體和材質創建Mesh
   plane_bridge.rotation.x = -Math.PI / 2; // 將平面旋轉為水平，面向上方
   plane_bridge.position.y = -1; // 將地面位置稍微下降，避免與模型重疊
   scene_bridge.add(plane_bridge); // 將平面添加到場景中

   // 創建相機
   camera_bridge = new THREE.PerspectiveCamera(C_bridgeC.fov, container_bridge.offsetWidth / container_bridge.offsetHeight, C_bridgeC.near, C_bridgeC.far); // 使用配置參數創建透視相機
   camera_bridge.position.set(C_bridgeC.position.x, C_bridgeC.position.y, C_bridgeC.position.z); // 設定相機位置
   camera_bridge.rotation.set(C_bridgeC.rotation._x, C_bridgeC.rotation._y, C_bridgeC.rotation._z); // 設定相機旋轉
   camera_bridge.quaternion.set(C_bridgeC.quaternion._x, C_bridgeC.quaternion._y, C_bridgeC.quaternion._z, C_bridgeC.quaternion._w); // 設定相機四元數，用於控制旋轉
   camera_bridge.zoom = C_bridgeC.zoom; // 設定相機的縮放級別
   camera_bridge.updateProjectionMatrix(); // 更新相機的投影矩陣

   // 初始化渲染器
   renderer_bridge = new THREE.WebGLRenderer(); // 創建WebGL渲染器
   renderer_bridge.setSize(container_bridge.offsetWidth, container_bridge.offsetHeight);
   container_bridge.appendChild(renderer_bridge.domElement); // 將渲染器的DOM元素掛載到HTML中的指定元素上

   labelRenderer_bridge = new CSS2DRenderer();
   labelRenderer_bridge.setSize(container_bridge.offsetWidth, container_bridge.offsetHeight);
   labelRenderer_bridge.domElement.style.position = "absolute";
   labelRenderer_bridge.domElement.style.top = "0px";
   container_bridge.appendChild(labelRenderer_bridge.domElement);
   // 添加照明
   light_bridge = new THREE.DirectionalLight(0xbbbbbb, 1); // 創建一個白色的方向光源
   light_bridge.position.set(1, 100, 1).normalize(); // 設定光源的位置並正規化
   scene_bridge.add(light_bridge); // 將光源添加到場景中

   // 實例化OrbitControls，允許用戶通過拖動來旋轉視角，滾動來縮放
   controls_bridge = new OrbitControls(camera_bridge, labelRenderer_bridge.domElement);
   controls_bridge.enableDamping = true; // 啟用阻尼效果，使交互更加平滑
   controls_bridge.dampingFactor = 0.25; // 設定阻尼系數
   controls_bridge.screenSpacePanning = false; // 禁用屏幕空間平移
   controls_bridge.target.set(C_bridgeC.target.x, C_bridgeC.target.y, C_bridgeC.target.z); // 設定控制的目標點
   controls_bridge.update(); // 更新控制器的內部狀態

   // 设置最小极角为0，防止低于地平面
   // Math.PI / 2 是90度，意味着视线平行于地面，不允许更低
   controls_bridge.minPolarAngle = 0; // 不允许移动到地面以下
   controls_bridge.maxPolarAngle = Math.PI / 2; // 最大旋转角度
   // Handle STL upload 

   // 呼叫 loadModels 函數來加載和顯示所有模型
   loadModels_bridge(bridgeData);

   document.getElementById('backButton').addEventListener('click', backOrverAll);
   document.getElementById('viewAButton').addEventListener('click', function () {

    camera_bridge.position.set(C_bridgeA.position.x, C_bridgeA.position.y, C_bridgeA.position.z); // 設定相機位置
    camera_bridge.rotation.set(C_bridgeA.rotation._x, C_bridgeA.rotation._y, C_bridgeA.rotation._z); // 設定相機旋轉
    camera_bridge.quaternion.set(C_bridgeA.quaternion._x, C_bridgeA.quaternion._y, C_bridgeA.quaternion._z, C_bridgeA.quaternion._w); // 設定相機四元數，用於控制旋轉
    camera_bridge.zoom = C_bridgeA.zoom; // 設定相機的縮放級別
    camera_bridge.updateProjectionMatrix(); // 更新相機的投影矩陣

    controls_bridge.target.set(C_bridgeA.target.x, C_bridgeA.target.y, C_bridgeA.target.z); // 設定控制的目標點
    controls_bridge.update(); // 更新控制器的內部狀態

   });
   document.getElementById('viewBButton').addEventListener('click', function () {


    camera_bridge.position.set(C_bridgeB.position.x, C_bridgeB.position.y, C_bridgeB.position.z); // 設定相機位置
    camera_bridge.rotation.set(C_bridgeB.rotation._x, C_bridgeB.rotation._y, C_bridgeB.rotation._z); // 設定相機旋轉
    camera_bridge.quaternion.set(C_bridgeB.quaternion._x, C_bridgeB.quaternion._y, C_bridgeB.quaternion._z, C_bridgeB.quaternion._w); // 設定相機四元數，用於控制旋轉
    camera_bridge.zoom = C_bridgeB.zoom; // 設定相機的縮放級別
    camera_bridge.updateProjectionMatrix(); // 更新相機的投影矩陣

    controls_bridge.target.set(C_bridgeB.target.x, C_bridgeB.target.y, C_bridgeB.target.z); // 設定控制的目標點
    controls_bridge.update(); // 更新控制器的內部狀態

   });
   document.getElementById('viewCButton').addEventListener('click', function () {


    camera_bridge.position.set(C_bridgeC.position.x, C_bridgeC.position.y, C_bridgeC.position.z); // 設定相機位置
    camera_bridge.rotation.set(C_bridgeC.rotation._x, C_bridgeC.rotation._y, C_bridgeC.rotation._z); // 設定相機旋轉
    camera_bridge.quaternion.set(C_bridgeC.quaternion._x, C_bridgeC.quaternion._y, C_bridgeC.quaternion._z, C_bridgeC.quaternion._w); // 設定相機四元數，用於控制旋轉
    camera_bridge.zoom = C_bridgeC.zoom; // 設定相機的縮放級別
    camera_bridge.updateProjectionMatrix(); // 更新相機的投影矩陣

    controls_bridge.target.set(C_bridgeC.target.x, C_bridgeC.target.y, C_bridgeC.target.z); // 設定控制的目標點
    controls_bridge.update(); // 更新控制器的內部狀態
   });
   raycaster_bridge = new THREE.Raycaster();
   mouse_bridge = new THREE.Vector2();
   // 滑鼠事件
   container_bridge.addEventListener('mousedown', onMouseDown_bridge, false);
   container_bridge.addEventListener('click', onMouseClick_bridge, false);
   container_bridge.addEventListener('dblclick', onMouseDblClick_bridge, false);
   container_bridge.addEventListener('mousemove', onMouseMove_bridge, false);

   let sumX = 0, sumY = 0, sumZ = 0;
   let count = 0;

   // 计算所有对象的坐标平均值
   scene_bridge.traverse(function (object) {
    if (object.isMesh) {
     sumX += object.position.x;
     sumY += object.position.y;
     sumZ += object.position.z;
     count++;
    }
   });

   const centerX = sumX / count;
   const centerY = sumY / count;
   const centerZ = sumZ / count;

   // 设置摄像机看向新的中心点
   camera_bridge.lookAt(centerX, centerY, centerZ);
   camera_bridge.updateProjectionMatrix();

   // 从 'A' 到 'T'
   var startChar = 'A'.charCodeAt(0);
   var endChar = 'T'.charCodeAt(0);

   for (let i = startChar; i <= endChar; i++) {
    let char = String.fromCharCode(i);
    // 创建颜色属性和初始值
    colors_bridge[char] = "#ffffff";

    // 添加颜色选择器到 GUI
    gui_bridge.addColor(colors_bridge, char).name(`Color ${char}`).onChange(function (value) {
     // 更新颜色
     var i = _objCollect_bridge.findIndex(x => x.obj_type == this.property);
     if (i > -1) _objCollect_bridge[i].material.color.set(evalue);
    });
   }
   gui_bridge.domElement.style.display = 'none';
   animate_bridge();
  }



  function animate() {
   requestAnimationFrame(animate);
   controls.update(); // 只有当 enableDamping 或 autoRotate 被设置时才需要
   renderer.render(scene, camera);
   labelRenderer.render(scene, camera);
  }


  function animate_bridge() {
   requestAnimationFrame(animate_bridge);
   controls_bridge.update(); // 只有当 enableDamping 或 autoRotate 被设置时才需要
   renderer_bridge.render(scene_bridge, camera_bridge);
   labelRenderer_bridge.render(scene_bridge, camera_bridge);
  }

  init();
  init_bridge();


  var event_count;


  function brideMouseOVer(a) {

   document.getElementById("event").value += event_count + ':brideMouseOVer ' + a + '\n';
   event_count++;
  }

  function bim_launchView(elementId) {
   event_count = 1;
   document.getElementById("event").value += event_count + ':bim_launchView ' + elementId + '\n';
   event_count++;
  }

  function ap_didLaunchView() {

   document.getElementById("event").value += event_count + ':ap_didLaunchView\n';
   event_count++;
  }

  function setOverallData() {
   bim_setOverallData(JSON.parse(document.getElementById("json").value));
  }

  let lastStatus = {}

  function bim_setOverallData(overallData) {
   document.getElementById("event").value += event_count + ':overallData\n';
   event_count++;
   overallData.gates.forEach(element => {
    setPlaneData(element.id, element.flightLegInfo.flightNumber + ' ' + element.flightLegInfo.aircraftType + '<br/>' + element.flightLegInfo.aTime + '<br/>' + element.flightLegInfo.dTime)
    setLabelData(element.id, element.name); // gates.name：文字顯示在#G1
    //gates.statusColor：顏色顯示在#G1, #G3
    setLabelDataColor(element.id, element.statusColor);
    setWindDataColor(element.id, element.statusColor);
    setWindData(element.id, '');
    if (element.windSpeedAvg && element.windSpeedMax) setWindData(element.id, element.windSpeedAvg + '/' + element.windSpeedMax);

    if (!lastStatus[element.id]) lastStatus[element.id] = { aTime: null, status: null };

    // aTime 值由 null 轉為有值時，播放飛機進場動畫。 (aTime==null && new_aTime!=null)
    if (lastStatus[element.id].aTime == null && element.flightLegInfo.aTime != null) runplay(element.id, 0, 0, 25, element.flightLegInfo.aircraftType);
    //由不為 4(服務)轉為 4(服務)時，播放空橋靠橋動畫。 (status!=4 && new_status==4)
    if (lastStatus[element.id].status != 4 && element.status == 4) runplay(element.id, 25, 25, 50);
    //當 status 值由 4(服務)轉為 2(閒置)或 5(撤橋)時，播放空橋撤橋動畫。(status==4 && (new_status==2 || new_status==5))
    if (lastStatus[element.id].status == 4 && (element.status == 2 || element.status == 5)) runplay(element.id, 0, 50, 75);
    //當aTime 由有值轉為 null 時，播放飛機離場動畫。(aTime!=null && new_aTime==null
    if (lastStatus[element.id].aTime != null && element.flightLegInfo.aTime == null) runplay(element.id, 0, 75, 100);


    //isHidden 是否隱藏。(true: 隱藏, false: 顯示)
    //isFlash 是否閃爍。(true: 閃爍, false: 不閃爍)
    //作用於#G1 是否閃爍
    if (element.isFlash)
     setLabelFlash(element.id);
    else
     clearLabelFlash(element.id);
    //作用於#G1 是否顯示
    setLabelVisible(element.id, element.isHidden);


    element.bridges.forEach(b_element => {
     setLabelData(b_element.id, b_element.name); // gates.name：文字顯示在#B
     if (b_element.isFlash)
      setLabelFlash(b_element.id);
     else
      clearLabelFlash(b_element.id);
     setLabelVisible(b_element.id, b_element.isHidden);
     //setVisible(element.id, b_element.id, null, b_element.isHidden);
     //setColor(element.id, b_element.id, null, b_element.statusColor);
     //：作用於#B2/ #B3/ #B4；若只有一個{}，僅會顯示#B2；如有 3 個{}，會顯示 #B2/ #B3/ #B4

     if (b_element.fireAlarm) {
      //C16_AL1_fire
      setLabelVisible(b_element.id + "L1_fire", false);
     }

     if (b_element.details.length == 1) {
      setVisible(element.id, b_element.id, 1, true);
      setVisible(element.id, b_element.id, 2, true);
     }
     if (b_element.details.length == 2) {
      setVisible(element.id, b_element.id, 2, true);
     }

     b_element.details.forEach((bi_element, index) => {

      if (b_element.isFlash)
       setFlash(b_element.id);
      else
       clearFlash(b_element.id);
      setVisible(element.id, b_element.id, index, b_element.isHidden);
      setColor(element.id, b_element.id, index, b_element.statusColor);
     });

    });

    lastStatus[element.id] = { aTime: element.flightLegInfo.aTime, status: element.status };
   });

  }

  function ap_showBridgeInfo(bridgeId) {
   document.getElementById("event").value += event_count + ':ap_showBridgeInfo ' + bridgeId + '\n';
   event_count++;

  }

  function ap_showBridgeDetailInfo(bridgeId, detailIndex) {
   document.getElementById("event").value += event_count + ':ap_showBridgeDetailInfo ' + bridgeId + ',' + detailIndex + '\n';
   event_count++;

  }

  let lastBridgeStatus = {}
  let currentbridgeId = {}
  
  function ap_didEnterBridgeScene(bridgeId) {
   currentbridgeId = bridgeId;
   document.getElementById("event").value += event_count + ':ap_didEnterBridgeScene ' + bridgeId + '\n';
   event_count++;
   document.getElementById("bridge_label").innerText = bridgeId + " 空橋狀況";
   if (!(bridgeId in lastBridgeStatus)) {
    lastBridgeStatus[bridgeId] = {
     "bridgeId": "E01_A",
     "status": [
      { "position": "A", "status": 1, "statusColor": "#ffffff" },
      { "position": "B", "status": 1, "statusColor": "#ffffff" },
      { "position": "C", "status": 1, "statusColor": "#ffffff" },
      { "position": "D", "status": 1, "statusColor": "#ffffff" },
      { "position": "E", "status": 1, "statusColor": "#ffffff" },
      { "position": "F", "status": 1, "statusColor": "#ffffff" },
      { "position": "G", "status": 1, "statusColor": "#ffffff" },
      { "position": "H", "status": 1, "statusColor": "#ffffff" },
      { "position": "I", "status": 1, "statusColor": "#ffffff" },
      { "position": "J", "status": 1, "statusColor": "#ffffff" },
      { "position": "K", "status": 1, "statusColor": "#ffffff" },
      { "position": "L", "status": 1, "statusColor": "#ffffff" },
      { "position": "M", "status": 1, "statusColor": "#ffffff" },
      { "position": "N", "status": 1, "statusColor": "#ffffff" },
      { "position": "O", "status": 1, "statusColor": "#ffffff" },
      { "position": "P", "status": 1, "statusColor": "#ffffff" },
      { "position": "Q", "status": 1, "statusColor": "#ffffff" },
      { "position": "R", "status": 1, "statusColor": "#ffffff" },
      { "position": "S", "status": 1, "statusColor": "#ffffff" },
      { "position": "T", "status": 1, "statusColor": "#ffffff" },
      { "position": "U", "status": 1, "statusColor": "#ffffff" }
     ],
     "fireAlarm": false
    }
   }
   lastBridgeStatus[bridgeId].status.forEach(element => {
    var i = _objCollect_bridge.findIndex(x => x.obj_type == element.position);
    if (i == -1) return;
    _objCollect_bridge[i].material.color.set(element.statusColor);
    //isHidden 是否隱藏。(true: 隱藏, false: 顯示)
    //isFlash 是否閃爍。(true: 閃爍, false: 不閃爍)
    if (element.isFlash)
     setFlash_bridge(element.position);
    else
     clearFlash_bridge(element.position);
    if (element.isHidden) {
     _objCollect_bridge[i].material.transparent = true;
     _objCollect_bridge[i].material.opacity = 0;
    }
    else {
     _objCollect_bridge[i].material.transparent = false;
     _objCollect_bridge[i].material.opacity = 1;
    }
   });
  }

  function setBridgeData() {
   bim_setBridgeData(JSON.parse(document.getElementById("json").value));
  }


  function bim_setBridgeData(bridgeData) {
   lastBridgeStatus[bridgeData.bridgeId] = bridgeData;
   document.getElementById("event").value += event_count + ':bim_setBridgeData\n';
   if(currentbridgeId != bridgeData.bridgeId) return;
   event_count++;
   bridgeData.status.forEach(element => {
    var i = _objCollect_bridge.findIndex(x => x.obj_type == element.position);
    if (i == -1) return;
    _objCollect_bridge[i].material.color.set(element.statusColor);
    //isHidden 是否隱藏。(true: 隱藏, false: 顯示)
    //isFlash 是否閃爍。(true: 閃爍, false: 不閃爍)
    if (element.isFlash)
     setFlash_bridge(element.position);
    else
     clearFlash_bridge(element.position);
    if (element.isHidden) {
     _objCollect_bridge[i].material.transparent = true;
     _objCollect_bridge[i].material.opacity = 0;
    }
    else {
     _objCollect_bridge[i].material.transparent = false;
     _objCollect_bridge[i].material.opacity = 1;
    }
   });

  }

  function ap_showBridgePositionInfo(bridgeId, position) {
   document.getElementById("event").value += event_count + ':ap_showBridgePositionInfo' + bridgeId + ',' + position + '\n';
   event_count++;

  }

  function ap_didLeaveBridgeScene(bridgeId) {
   document.getElementById("event").value += event_count + ':ap_didLeaveBridgeScene' + bridgeId + '\n';
   event_count++;

  }
 </script>
</body>

</html>